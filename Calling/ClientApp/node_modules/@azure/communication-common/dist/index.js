'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib = require('tslib');
var jwtDecode = _interopDefault(require('jwt-decode'));
var coreHttp = require('@azure/core-http');
var crypto = require('crypto');
var coreAuth = require('@azure/core-auth');

// Copyright (c) Microsoft Corporation.
const parseToken = (token) => {
    const { exp } = jwtDecode(token);
    return {
        token,
        expiresOnTimestamp: exp * 1000
    };
};

// Copyright (c) Microsoft Corporation.
/**
 * StaticTokenCredential
 */
class StaticTokenCredential {
    constructor(token) {
        this.token = token;
    }
    getToken() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.token;
        });
    }
    dispose() {
        /* intentionally empty */
    }
}

// Copyright (c) Microsoft Corporation.
const expiredToken = { token: "", expiresOnTimestamp: -10 };
const minutesToMs = (minutes) => minutes * 1000 * 60;
const defaultRefreshingInterval = minutesToMs(10);
class AutoRefreshUserCredential {
    constructor(refreshArgs) {
        this.refreshingIntervalInMs = defaultRefreshingInterval;
        this.activeTokenFetching = null;
        this.activeTokenUpdating = null;
        this.disposed = false;
        const { tokenRefresher, initialToken, refreshProactively } = refreshArgs;
        this.refresh = tokenRefresher;
        this.currentToken = initialToken ? parseToken(initialToken) : expiredToken;
        this.refreshProactively = refreshProactively !== null && refreshProactively !== void 0 ? refreshProactively : false;
        if (this.refreshProactively) {
            this.scheduleRefresh();
        }
    }
    getToken(abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!this.isCurrentTokenExpiringSoon) {
                return this.currentToken;
            }
            const updatePromise = this.updateTokenAndReschedule(abortSignal);
            if (!this.isCurrentTokenValid) {
                yield updatePromise;
            }
            return this.currentToken;
        });
    }
    dispose() {
        this.disposed = true;
        this.activeTokenFetching = null;
        this.activeTokenUpdating = null;
        this.currentToken = expiredToken;
        if (this.activeTimeout) {
            clearTimeout(this.activeTimeout);
        }
    }
    updateTokenAndReschedule(abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.activeTokenUpdating) {
                return this.activeTokenUpdating;
            }
            this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);
            try {
                yield this.activeTokenUpdating;
            }
            finally {
                this.activeTokenUpdating = null;
            }
        });
    }
    refreshTokenAndReschedule(abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this.currentToken = yield this.refreshToken(abortSignal);
            if (this.refreshProactively) {
                this.scheduleRefresh();
            }
        });
    }
    refreshToken(abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.activeTokenFetching) {
                    this.activeTokenFetching = this.refresh(abortSignal);
                }
                return parseToken(yield this.activeTokenFetching);
            }
            finally {
                this.activeTokenFetching = null;
            }
        });
    }
    scheduleRefresh() {
        if (this.disposed) {
            return;
        }
        if (this.activeTimeout) {
            clearTimeout(this.activeTimeout);
        }
        const timespanInMs = this.currentToken.expiresOnTimestamp - Date.now() - this.refreshingIntervalInMs;
        this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);
    }
    get isCurrentTokenValid() {
        return this.currentToken && Date.now() < this.currentToken.expiresOnTimestamp;
    }
    get isCurrentTokenExpiringSoon() {
        return (!this.currentToken ||
            Date.now() >= this.currentToken.expiresOnTimestamp - this.refreshingIntervalInMs);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The CommunicationUserCredential implementation with support for proactive token refresh.
 */
class AzureCommunicationUserCredential {
    constructor(tokenOrRefreshOptions) {
        this.disposed = false;
        if (typeof tokenOrRefreshOptions === "string") {
            this.userCredential = new StaticTokenCredential(parseToken(tokenOrRefreshOptions));
        }
        else {
            this.userCredential = new AutoRefreshUserCredential(tokenOrRefreshOptions);
        }
    }
    /**
     * Gets an `AccessToken` for the user. Throws if already disposed.
     * @param abortSignal An implementation of `AbortSignalLike` to cancel the operation.
     */
    getToken(abortSignal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this.throwIfDisposed();
            const token = yield this.userCredential.getToken(abortSignal);
            this.throwIfDisposed();
            return token;
        });
    }
    /**
     * Disposes the CommunicationUserCredential and cancels any internal auto-refresh operation.
     */
    dispose() {
        this.disposed = true;
        this.userCredential.dispose();
    }
    throwIfDisposed() {
        if (this.disposed) {
            throw new Error("User credential is disposed");
        }
    }
}

// Copyright (c) Microsoft Corporation.
const shaHash = (content) => tslib.__awaiter(void 0, void 0, void 0, function* () {
    return crypto.createHash("sha256")
        .update(content)
        .digest("base64");
});
const shaHMAC = (secret, content) => tslib.__awaiter(void 0, void 0, void 0, function* () {
    const decodedSecret = Buffer.from(secret, "base64");
    return crypto.createHmac("sha256", decodedSecret)
        .update(content)
        .digest("base64");
});

// Copyright (c) Microsoft Corporation.
/**
 * Creates an HTTP pipeline policy to authenticate a request
 * using an `KeyCredential`
 *
 * @param {KeyCredential} credential The key credential
 */
const createCommunicationAccessKeyCredentialPolicy = (credential) => {
    return {
        create: (nextpolicy, options) => {
            return new CommunicationAccessKeyCredentialPolicy(credential, nextpolicy, options);
        }
    };
};
/**
 * CommunicationAccessKeyCredentialPolicy provides a means of signing requests made through
 * the SmsClient.
 */
class CommunicationAccessKeyCredentialPolicy extends coreHttp.BaseRequestPolicy {
    /**
     * Initializes a new instance of the CommunicationAccessKeyCredential class
     * using a base64 encoded key.
     * @param accessKey The base64 encoded key to be used for signing.
     */
    constructor(accessKey, nextPolicy, options) {
        super(nextPolicy, options);
        this.accessKey = accessKey;
    }
    /**
     * Signs a request with the provided access key.
     *
     * @param {WebResource} webResource The WebResource to be signed.
     */
    signRequest(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const verb = webResource.method.toUpperCase();
            const utcNow = new Date().toUTCString();
            const contentHash = yield shaHash(webResource.body || "");
            const dateHeader = coreHttp.isNode ? "date" : "x-ms-date";
            const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;
            const url = coreHttp.URLBuilder.parse(webResource.url);
            const query = url.getQuery();
            const urlPathAndQuery = query ? `${url.getPath()}?${query}` : url.getPath();
            const port = url.getPort();
            const hostAndPort = port ? `${url.getHost()}:${port}` : url.getHost();
            const stringToSign = `${verb}\n${urlPathAndQuery}\n${utcNow};${hostAndPort};${contentHash}`;
            const signature = yield shaHMAC(this.accessKey.key, stringToSign);
            {
                webResource.headers.set("Host", hostAndPort || "");
            }
            webResource.headers.set(dateHeader, utcNow);
            webResource.headers.set("x-ms-content-sha256", contentHash);
            webResource.headers.set("Authorization", `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`);
            return webResource;
        });
    }
    /**
     * Signs the request and calls the next policy in the factory.
     *
     * @param {WebResourceLike} webResource
     */
    sendRequest(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!webResource) {
                throw new Error("webResource cannot be null or undefined");
            }
            return this._nextPolicy.sendRequest(yield this.signRequest(webResource));
        });
    }
}

// Copyright (c) Microsoft Corporation.
// TODO: update when connection string format is finalized
const CONNECTION_STRING_REGEX = /endpoint=(.*);accesskey=(.*)/i;
const tryParseConnectionString = (s) => {
    const match = s.match(CONNECTION_STRING_REGEX);
    if ((match === null || match === void 0 ? void 0 : match[1]) && match[2]) {
        return { endpoint: match[1], credential: new coreAuth.AzureKeyCredential(match[2]) };
    }
    return undefined;
};
const parseConnectionString = (connectionString) => {
    const parsedConnectionString = tryParseConnectionString(connectionString);
    if (parsedConnectionString) {
        return parsedConnectionString;
    }
    else {
        throw new Error(`Invalid connection string ${connectionString}`);
    }
};

// Copyright (c) Microsoft Corporation.
const isValidEndpoint = (host) => {
    var _a;
    const url = coreHttp.URLBuilder.parse(host);
    return (!!((_a = url.getScheme()) === null || _a === void 0 ? void 0 : _a.match(/^http[s]?/)) &&
        url.getHost() !== undefined &&
        url.getHost() !== "" &&
        (url.getPath() === undefined || url.getPath() === "" || url.getPath() === "/"));
};
const assertValidEndpoint = (host) => {
    if (!isValidEndpoint(host)) {
        throw new Error(`Invalid endpoint url ${host}`);
    }
};
/**
 * Checks whether a value is a KeyCredential.
 *
 * @param {*} credential The credential being checked.
 */
const isKeyCredential = (credential) => {
    return credential && typeof credential.key === "string" && credential.getToken === undefined;
};
/**
 * Parses arguments passed to a communication client.
 *
 * @param {string} connectionStringOrUrl
 * @param {*} [credentialOrOptions]
 */
const parseClientArguments = (connectionStringOrUrl, credentialOrOptions) => {
    if (isKeyCredential(credentialOrOptions)) {
        assertValidEndpoint(connectionStringOrUrl);
        return { url: connectionStringOrUrl, credential: credentialOrOptions };
    }
    else {
        const { endpoint: host, credential } = parseConnectionString(connectionStringOrUrl);
        assertValidEndpoint(host);
        return { url: host, credential };
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Tests an Identifier to determine whether it implements CommunicationUser.
 *
 * @param identifier The assumed CommunicationUser to be tested.
 */
const isCommunicationUser = (identifier) => {
    return typeof identifier.communicationUserId === "string";
};
/**
 * Tests an Identifier to determine whether it implements PhoneNumber.
 *
 * @param identifier The assumed PhoneNumber to be tested.
 */
const isPhoneNumber = (identifier) => {
    return typeof identifier.phoneNumber === "string";
};
/**
 * Tests an Identifier to determine whether it implements CallingApplication.
 *
 * @param identifier The assumed CallingApplication to be tested.
 */
const isCallingApplication = (identifier) => {
    return typeof identifier.callingApplicationId === "string";
};
/**
 * Tests an Identifier to determine whether it implements UnknownIdentifier.
 *
 * @param identifier The assumed UnknownIdentifier to be tested.
 */
const isUnknownIdentifier = (identifier) => {
    return typeof identifier.id === "string";
};
/**
 * Returns the IdentifierKind for a given Identifier. Returns undefined if the kind couldn't be inferred.
 *
 * @param identifier The identifier whose kind is to be inferred.
 */
const getIdentifierKind = (identifier) => {
    if (isCommunicationUser(identifier)) {
        return Object.assign(Object.assign({}, identifier), { kind: "CommunicationUser" });
    }
    if (isPhoneNumber(identifier)) {
        return Object.assign(Object.assign({}, identifier), { kind: "PhoneNumber" });
    }
    if (isCallingApplication(identifier)) {
        return Object.assign(Object.assign({}, identifier), { kind: "CallingApplication" });
    }
    return Object.assign(Object.assign({}, identifier), { kind: "Unknown" });
};

exports.AzureCommunicationUserCredential = AzureCommunicationUserCredential;
exports.createCommunicationAccessKeyCredentialPolicy = createCommunicationAccessKeyCredentialPolicy;
exports.getIdentifierKind = getIdentifierKind;
exports.isCallingApplication = isCallingApplication;
exports.isCommunicationUser = isCommunicationUser;
exports.isKeyCredential = isKeyCredential;
exports.isPhoneNumber = isPhoneNumber;
exports.isUnknownIdentifier = isUnknownIdentifier;
exports.parseClientArguments = parseClientArguments;
//# sourceMappingURL=index.js.map
