{"version":3,"file":"autoRefreshUserCredential.js","sourceRoot":"","sources":["../../src/autoRefreshUserCredential.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;;AAGlC,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAwB3C,MAAM,YAAY,GAAG,EAAE,KAAK,EAAE,EAAE,EAAE,kBAAkB,EAAE,CAAC,EAAE,EAAE,CAAC;AAC5D,MAAM,WAAW,GAAG,CAAC,OAAe,EAAU,EAAE,CAAC,OAAO,GAAG,IAAI,GAAG,EAAE,CAAC;AACrE,MAAM,yBAAyB,GAAG,WAAW,CAAC,EAAE,CAAC,CAAC;AAElD,MAAM,OAAO,yBAAyB;IAWpC,YAAY,WAA2B;QARtB,2BAAsB,GAAW,yBAAyB,CAAC;QAIpE,wBAAmB,GAA2B,IAAI,CAAC;QACnD,wBAAmB,GAAyB,IAAI,CAAC;QACjD,aAAQ,GAAG,KAAK,CAAC;QAGvB,MAAM,EAAE,cAAc,EAAE,YAAY,EAAE,kBAAkB,EAAE,GAAG,WAAW,CAAC;QAEzE,IAAI,CAAC,OAAO,GAAG,cAAc,CAAC;QAC9B,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC;QAC3E,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,aAAlB,kBAAkB,cAAlB,kBAAkB,GAAI,KAAK,CAAC;QAEtD,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC3B,IAAI,CAAC,eAAe,EAAE,CAAC;SACxB;IACH,CAAC;IAEY,QAAQ,CAAC,WAA6B;;YACjD,IAAI,CAAC,IAAI,CAAC,0BAA0B,EAAE;gBACpC,OAAO,IAAI,CAAC,YAAY,CAAC;aAC1B;YAED,MAAM,aAAa,GAAG,IAAI,CAAC,wBAAwB,CAAC,WAAW,CAAC,CAAC;YAEjE,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE;gBAC7B,MAAM,aAAa,CAAC;aACrB;YAED,OAAO,IAAI,CAAC,YAAY,CAAC;QAC3B,CAAC;KAAA;IAEM,OAAO;QACZ,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;QAChC,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;QAChC,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;SAClC;IACH,CAAC;IAEa,wBAAwB,CAAC,WAA6B;;YAClE,IAAI,IAAI,CAAC,mBAAmB,EAAE;gBAC5B,OAAO,IAAI,CAAC,mBAAmB,CAAC;aACjC;YACD,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,yBAAyB,CAAC,WAAW,CAAC,CAAC;YACvE,IAAI;gBACF,MAAM,IAAI,CAAC,mBAAmB,CAAC;aAChC;oBAAS;gBACR,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;aACjC;QACH,CAAC;KAAA;IAEa,yBAAyB,CAAC,WAA6B;;YACnE,IAAI,CAAC,YAAY,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;YACzD,IAAI,IAAI,CAAC,kBAAkB,EAAE;gBAC3B,IAAI,CAAC,eAAe,EAAE,CAAC;aACxB;QACH,CAAC;KAAA;IAEa,YAAY,CAAC,WAA6B;;YACtD,IAAI;gBACF,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE;oBAC7B,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;iBACtD;gBACD,OAAO,UAAU,CAAC,MAAM,IAAI,CAAC,mBAAmB,CAAC,CAAC;aACnD;oBAAS;gBACR,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;aACjC;QACH,CAAC;KAAA;IAEO,eAAe;QACrB,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,OAAO;SACR;QACD,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;SAClC;QACD,MAAM,YAAY,GAChB,IAAI,CAAC,YAAY,CAAC,kBAAkB,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,sBAAsB,CAAC;QAClF,IAAI,CAAC,aAAa,GAAG,UAAU,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,wBAAwB,EAAE,EAAE,YAAY,CAAC,CAAC;IACvF,CAAC;IAED,IAAY,mBAAmB;QAC7B,OAAO,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,kBAAkB,CAAC;IAChF,CAAC;IAED,IAAY,0BAA0B;QACpC,OAAO,CACL,CAAC,IAAI,CAAC,YAAY;YAClB,IAAI,CAAC,GAAG,EAAE,IAAI,IAAI,CAAC,YAAY,CAAC,kBAAkB,GAAG,IAAI,CAAC,sBAAsB,CACjF,CAAC;IACJ,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike, AccessToken } from \"@azure/core-http\";\nimport { parseToken } from \"./tokenParser\";\nimport { UserCredential } from \"./communicationUserCredential\";\n\n/**\n * Options for auto-refreshing a Communication user credential.\n */\nexport interface RefreshOptions {\n  /**\n   * Function that returns a user token acquired from the Communication configuration SDK.\n   */\n  tokenRefresher: (abortSignal?: AbortSignalLike) => Promise<string>;\n\n  /**\n   * Optional user token to initialize.\n   */\n  initialToken?: string;\n\n  /**\n   * Indicates whether the user token should be proactively renewed prior to expiry or only renew on demand.\n   * By default false.\n   */\n  refreshProactively?: boolean;\n}\n\nconst expiredToken = { token: \"\", expiresOnTimestamp: -10 };\nconst minutesToMs = (minutes: number): number => minutes * 1000 * 60;\nconst defaultRefreshingInterval = minutesToMs(10);\n\nexport class AutoRefreshUserCredential implements UserCredential {\n  private readonly refresh: (abortSignal?: AbortSignalLike) => Promise<string>;\n  private readonly refreshProactively: boolean;\n  private readonly refreshingIntervalInMs: number = defaultRefreshingInterval;\n\n  private currentToken: AccessToken;\n  private activeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private activeTokenFetching: Promise<string> | null = null;\n  private activeTokenUpdating: Promise<void> | null = null;\n  private disposed = false;\n\n  constructor(refreshArgs: RefreshOptions) {\n    const { tokenRefresher, initialToken, refreshProactively } = refreshArgs;\n\n    this.refresh = tokenRefresher;\n    this.currentToken = initialToken ? parseToken(initialToken) : expiredToken;\n    this.refreshProactively = refreshProactively ?? false;\n\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  public async getToken(abortSignal?: AbortSignalLike): Promise<AccessToken> {\n    if (!this.isCurrentTokenExpiringSoon) {\n      return this.currentToken;\n    }\n\n    const updatePromise = this.updateTokenAndReschedule(abortSignal);\n\n    if (!this.isCurrentTokenValid) {\n      await updatePromise;\n    }\n\n    return this.currentToken;\n  }\n\n  public dispose(): void {\n    this.disposed = true;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.currentToken = expiredToken;\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n  }\n\n  private async updateTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    if (this.activeTokenUpdating) {\n      return this.activeTokenUpdating;\n    }\n    this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);\n    try {\n      await this.activeTokenUpdating;\n    } finally {\n      this.activeTokenUpdating = null;\n    }\n  }\n\n  private async refreshTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    this.currentToken = await this.refreshToken(abortSignal);\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  private async refreshToken(abortSignal?: AbortSignalLike): Promise<AccessToken> {\n    try {\n      if (!this.activeTokenFetching) {\n        this.activeTokenFetching = this.refresh(abortSignal);\n      }\n      return parseToken(await this.activeTokenFetching);\n    } finally {\n      this.activeTokenFetching = null;\n    }\n  }\n\n  private scheduleRefresh(): void {\n    if (this.disposed) {\n      return;\n    }\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n    const timespanInMs =\n      this.currentToken.expiresOnTimestamp - Date.now() - this.refreshingIntervalInMs;\n    this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);\n  }\n\n  private get isCurrentTokenValid(): boolean {\n    return this.currentToken && Date.now() < this.currentToken.expiresOnTimestamp;\n  }\n\n  private get isCurrentTokenExpiringSoon(): boolean {\n    return (\n      !this.currentToken ||\n      Date.now() >= this.currentToken.expiresOnTimestamp - this.refreshingIntervalInMs\n    );\n  }\n}\n"]}