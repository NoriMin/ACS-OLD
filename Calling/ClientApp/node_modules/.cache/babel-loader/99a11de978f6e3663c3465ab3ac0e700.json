{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\t-tamina\\\\source\\\\repos\\\\Communication\\\\samples\\\\Group Calling Hero Sample\\\\Web\\\\Calling\\\\ClientApp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _classCallCheck from \"C:\\\\Users\\\\t-tamina\\\\source\\\\repos\\\\Communication\\\\samples\\\\Group Calling Hero Sample\\\\Web\\\\Calling\\\\ClientApp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\t-tamina\\\\source\\\\repos\\\\Communication\\\\samples\\\\Group Calling Hero Sample\\\\Web\\\\Calling\\\\ClientApp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\t-tamina\\\\source\\\\repos\\\\Communication\\\\samples\\\\Group Calling Hero Sample\\\\Web\\\\Calling\\\\ClientApp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\t-tamina\\\\source\\\\repos\\\\Communication\\\\samples\\\\Group Calling Hero Sample\\\\Web\\\\Calling\\\\ClientApp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __awaiter } from \"tslib\";\nimport { URLBuilder, isNode, BaseRequestPolicy } from \"@azure/core-http\";\nimport { shaHash, shaHMAC } from \"./cryptoUtils\";\n/**\n * Creates an HTTP pipeline policy to authenticate a request\n * using an `KeyCredential`\n *\n * @param {KeyCredential} credential The key credential\n */\n\nexport var createCommunicationAccessKeyCredentialPolicy = function createCommunicationAccessKeyCredentialPolicy(credential) {\n  return {\n    create: function create(nextpolicy, options) {\n      return new CommunicationAccessKeyCredentialPolicy(credential, nextpolicy, options);\n    }\n  };\n};\n/**\n * CommunicationAccessKeyCredentialPolicy provides a means of signing requests made through\n * the SmsClient.\n */\n\nvar CommunicationAccessKeyCredentialPolicy = /*#__PURE__*/function (_BaseRequestPolicy) {\n  _inherits(CommunicationAccessKeyCredentialPolicy, _BaseRequestPolicy);\n\n  var _super = _createSuper(CommunicationAccessKeyCredentialPolicy);\n\n  /**\n   * Initializes a new instance of the CommunicationAccessKeyCredential class\n   * using a base64 encoded key.\n   * @param accessKey The base64 encoded key to be used for signing.\n   */\n  function CommunicationAccessKeyCredentialPolicy(accessKey, nextPolicy, options) {\n    var _this;\n\n    _classCallCheck(this, CommunicationAccessKeyCredentialPolicy);\n\n    _this = _super.call(this, nextPolicy, options);\n    _this.accessKey = accessKey;\n    return _this;\n  }\n  /**\n   * Signs a request with the provided access key.\n   *\n   * @param {WebResource} webResource The WebResource to be signed.\n   */\n\n\n  _createClass(CommunicationAccessKeyCredentialPolicy, [{\n    key: \"signRequest\",\n    value: function signRequest(webResource) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var verb, utcNow, contentHash, dateHeader, signedHeaders, url, query, urlPathAndQuery, port, hostAndPort, stringToSign, signature;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                verb = webResource.method.toUpperCase();\n                utcNow = new Date().toUTCString();\n                _context.next = 4;\n                return shaHash(webResource.body || \"\");\n\n              case 4:\n                contentHash = _context.sent;\n                dateHeader = isNode ? \"date\" : \"x-ms-date\";\n                signedHeaders = \"\".concat(dateHeader, \";host;x-ms-content-sha256\");\n                url = URLBuilder.parse(webResource.url);\n                query = url.getQuery();\n                urlPathAndQuery = query ? \"\".concat(url.getPath(), \"?\").concat(query) : url.getPath();\n                port = url.getPort();\n                hostAndPort = port ? \"\".concat(url.getHost(), \":\").concat(port) : url.getHost();\n                stringToSign = \"\".concat(verb, \"\\n\").concat(urlPathAndQuery, \"\\n\").concat(utcNow, \";\").concat(hostAndPort, \";\").concat(contentHash);\n                _context.next = 15;\n                return shaHMAC(this.accessKey.key, stringToSign);\n\n              case 15:\n                signature = _context.sent;\n\n                if (isNode) {\n                  webResource.headers.set(\"Host\", hostAndPort || \"\");\n                }\n\n                webResource.headers.set(dateHeader, utcNow);\n                webResource.headers.set(\"x-ms-content-sha256\", contentHash);\n                webResource.headers.set(\"Authorization\", \"HMAC-SHA256 SignedHeaders=\".concat(signedHeaders, \"&Signature=\").concat(signature));\n                return _context.abrupt(\"return\", webResource);\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Signs the request and calls the next policy in the factory.\n     *\n     * @param {WebResourceLike} webResource\n     */\n\n  }, {\n    key: \"sendRequest\",\n    value: function sendRequest(webResource) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (webResource) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error(\"webResource cannot be null or undefined\");\n\n              case 2:\n                _context2.t0 = this._nextPolicy;\n                _context2.next = 5;\n                return this.signRequest(webResource);\n\n              case 5:\n                _context2.t1 = _context2.sent;\n                return _context2.abrupt(\"return\", _context2.t0.sendRequest.call(_context2.t0, _context2.t1));\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }]);\n\n  return CommunicationAccessKeyCredentialPolicy;\n}(BaseRequestPolicy);","map":{"version":3,"sources":["../../../src/credential/communicationAccessKeyCredentialPolicy.ts"],"names":[],"mappings":";;;;;AAAA;AACA;;AAGA,SACE,UADF,EAGE,MAHF,EASE,iBATF,QAUO,kBAVP;AAWA,SAAS,OAAT,EAAkB,OAAlB,QAAiC,eAAjC;AAEA;;;;;;;AAMA,OAAO,IAAM,4CAA4C,GAAG,SAA/C,4CAA+C,CAC1D,UAD0D,EAElC;AACxB,SAAO;AACL,IAAA,MAAM,EAAE,gBAAC,UAAD,EAA4B,OAA5B,EAAiE;AACvE,aAAO,IAAI,sCAAJ,CAA2C,UAA3C,EAAuD,UAAvD,EAAmE,OAAnE,CAAP;AACD;AAHI,GAAP;AAKD,CARM;AAUP;;;;;IAIM,sC;;;;;AACJ;;;;;AAKA,kDACmB,SADnB,EAEE,UAFF,EAGE,OAHF,EAGmC;AAAA;;AAAA;;AAEjC,8BAAM,UAAN,EAAkB,OAAlB;AAJiB,UAAA,SAAA,GAAA,SAAA;AAEgB;AAGlC;AAED;;;;;;;;;gCAK0B,W,EAAwB;;;;;;;AAC1C,gBAAA,I,GAAO,WAAW,CAAC,MAAZ,CAAmB,WAAnB,E;AACP,gBAAA,M,GAAS,IAAI,IAAJ,GAAW,WAAX,E;;AACK,uBAAM,OAAO,CAAC,WAAW,CAAC,IAAZ,IAAoB,EAArB,CAAb;;;AAAd,gBAAA,W;AACA,gBAAA,U,GAAa,MAAM,GAAG,MAAH,GAAY,W;AAC/B,gBAAA,a,aAAmB,U;AAEnB,gBAAA,G,GAAM,UAAU,CAAC,KAAX,CAAiB,WAAW,CAAC,GAA7B,C;AACN,gBAAA,K,GAAQ,GAAG,CAAC,QAAJ,E;AACR,gBAAA,e,GAAkB,KAAK,aAAM,GAAG,CAAC,OAAJ,EAAN,cAAuB,KAAvB,IAAiC,GAAG,CAAC,OAAJ,E;AACxD,gBAAA,I,GAAO,GAAG,CAAC,OAAJ,E;AACP,gBAAA,W,GAAc,IAAI,aAAM,GAAG,CAAC,OAAJ,EAAN,cAAuB,IAAvB,IAAgC,GAAG,CAAC,OAAJ,E;AAElD,gBAAA,Y,aAAkB,I,eAAS,e,eAAoB,M,cAAU,W,cAAe,W;;AAC5D,uBAAM,OAAO,CAAC,KAAK,SAAL,CAAe,GAAhB,EAAqB,YAArB,CAAb;;;AAAZ,gBAAA,S;;AAEN,oBAAI,MAAJ,EAAY;AACV,kBAAA,WAAW,CAAC,OAAZ,CAAoB,GAApB,CAAwB,MAAxB,EAAgC,WAAW,IAAI,EAA/C;AACD;;AAED,gBAAA,WAAW,CAAC,OAAZ,CAAoB,GAApB,CAAwB,UAAxB,EAAoC,MAApC;AACA,gBAAA,WAAW,CAAC,OAAZ,CAAoB,GAApB,CAAwB,qBAAxB,EAA+C,WAA/C;AACA,gBAAA,WAAW,CAAC,OAAZ,CAAoB,GAApB,CACE,eADF,sCAE+B,aAF/B,wBAE0D,SAF1D;iDAKO,W;;;;;;;;;AACR;AAED;;;;;;;;gCAKyB,W,EAA4B;;;;;;oBAC9C,W;;;;;sBACG,IAAI,KAAJ,CAAU,yCAAV,C;;;+BAGD,KAAK,W;;AAAwB,uBAAM,KAAK,WAAL,CAAiB,WAAjB,CAAN;;;;+DAAZ,W;;;;;;;;;AACzB;;;;EA5DkD,iB","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { KeyCredential } from \"@azure/core-auth\";\nimport {\n  URLBuilder,\n  WebResource,\n  isNode,\n  RequestPolicy,\n  RequestPolicyOptionsLike,\n  RequestPolicyFactory,\n  WebResourceLike,\n  HttpOperationResponse,\n  BaseRequestPolicy\n} from \"@azure/core-http\";\nimport { shaHash, shaHMAC } from \"./cryptoUtils\";\n\n/**\n * Creates an HTTP pipeline policy to authenticate a request\n * using an `KeyCredential`\n *\n * @param {KeyCredential} credential The key credential\n */\nexport const createCommunicationAccessKeyCredentialPolicy = (\n  credential: KeyCredential\n): RequestPolicyFactory => {\n  return {\n    create: (nextpolicy: RequestPolicy, options: RequestPolicyOptionsLike) => {\n      return new CommunicationAccessKeyCredentialPolicy(credential, nextpolicy, options);\n    }\n  };\n};\n\n/**\n * CommunicationAccessKeyCredentialPolicy provides a means of signing requests made through\n * the SmsClient.\n */\nclass CommunicationAccessKeyCredentialPolicy extends BaseRequestPolicy {\n  /**\n   * Initializes a new instance of the CommunicationAccessKeyCredential class\n   * using a base64 encoded key.\n   * @param accessKey The base64 encoded key to be used for signing.\n   */\n  constructor(\n    private readonly accessKey: KeyCredential,\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptionsLike\n  ) {\n    super(nextPolicy, options);\n  }\n\n  /**\n   * Signs a request with the provided access key.\n   *\n   * @param {WebResource} webResource The WebResource to be signed.\n   */\n  private async signRequest(webResource: WebResource): Promise<WebResource> {\n    const verb = webResource.method.toUpperCase();\n    const utcNow = new Date().toUTCString();\n    const contentHash = await shaHash(webResource.body || \"\");\n    const dateHeader = isNode ? \"date\" : \"x-ms-date\";\n    const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;\n\n    const url = URLBuilder.parse(webResource.url);\n    const query = url.getQuery();\n    const urlPathAndQuery = query ? `${url.getPath()}?${query}` : url.getPath();\n    const port = url.getPort();\n    const hostAndPort = port ? `${url.getHost()}:${port}` : url.getHost();\n\n    const stringToSign = `${verb}\\n${urlPathAndQuery}\\n${utcNow};${hostAndPort};${contentHash}`;\n    const signature = await shaHMAC(this.accessKey.key, stringToSign);\n\n    if (isNode) {\n      webResource.headers.set(\"Host\", hostAndPort || \"\");\n    }\n\n    webResource.headers.set(dateHeader, utcNow);\n    webResource.headers.set(\"x-ms-content-sha256\", contentHash);\n    webResource.headers.set(\n      \"Authorization\",\n      `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`\n    );\n\n    return webResource;\n  }\n\n  /**\n   * Signs the request and calls the next policy in the factory.\n   *\n   * @param {WebResourceLike} webResource\n   */\n  public async sendRequest(webResource: WebResourceLike): Promise<HttpOperationResponse> {\n    if (!webResource) {\n      throw new Error(\"webResource cannot be null or undefined\");\n    }\n\n    return this._nextPolicy.sendRequest(await this.signRequest(webResource));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}