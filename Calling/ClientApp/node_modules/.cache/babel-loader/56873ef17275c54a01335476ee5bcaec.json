{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\t-tamina\\\\source\\\\repos\\\\Communication\\\\samples\\\\Group Calling Hero Sample\\\\Web\\\\Calling\\\\ClientApp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _classCallCheck from \"C:\\\\Users\\\\t-tamina\\\\source\\\\repos\\\\Communication\\\\samples\\\\Group Calling Hero Sample\\\\Web\\\\Calling\\\\ClientApp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\t-tamina\\\\source\\\\repos\\\\Communication\\\\samples\\\\Group Calling Hero Sample\\\\Web\\\\Calling\\\\ClientApp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __awaiter } from \"tslib\";\nimport { parseToken } from \"./tokenParser\";\nvar expiredToken = {\n  token: \"\",\n  expiresOnTimestamp: -10\n};\n\nvar minutesToMs = function minutesToMs(minutes) {\n  return minutes * 1000 * 60;\n};\n\nvar defaultRefreshingInterval = minutesToMs(10);\nexport var AutoRefreshUserCredential = /*#__PURE__*/function () {\n  function AutoRefreshUserCredential(refreshArgs) {\n    _classCallCheck(this, AutoRefreshUserCredential);\n\n    this.refreshingIntervalInMs = defaultRefreshingInterval;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.disposed = false;\n    var tokenRefresher = refreshArgs.tokenRefresher,\n        initialToken = refreshArgs.initialToken,\n        refreshProactively = refreshArgs.refreshProactively;\n    this.refresh = tokenRefresher;\n    this.currentToken = initialToken ? parseToken(initialToken) : expiredToken;\n    this.refreshProactively = refreshProactively !== null && refreshProactively !== void 0 ? refreshProactively : false;\n\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  _createClass(AutoRefreshUserCredential, [{\n    key: \"getToken\",\n    value: function getToken(abortSignal) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var updatePromise;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.isCurrentTokenExpiringSoon) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this.currentToken);\n\n              case 2:\n                updatePromise = this.updateTokenAndReschedule(abortSignal);\n\n                if (this.isCurrentTokenValid) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _context.next = 6;\n                return updatePromise;\n\n              case 6:\n                return _context.abrupt(\"return\", this.currentToken);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.disposed = true;\n      this.activeTokenFetching = null;\n      this.activeTokenUpdating = null;\n      this.currentToken = expiredToken;\n\n      if (this.activeTimeout) {\n        clearTimeout(this.activeTimeout);\n      }\n    }\n  }, {\n    key: \"updateTokenAndReschedule\",\n    value: function updateTokenAndReschedule(abortSignal) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.activeTokenUpdating) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this.activeTokenUpdating);\n\n              case 2:\n                this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);\n                _context2.prev = 3;\n                _context2.next = 6;\n                return this.activeTokenUpdating;\n\n              case 6:\n                _context2.prev = 6;\n                this.activeTokenUpdating = null;\n                return _context2.finish(6);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[3,, 6, 9]]);\n      }));\n    }\n  }, {\n    key: \"refreshTokenAndReschedule\",\n    value: function refreshTokenAndReschedule(abortSignal) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.refreshToken(abortSignal);\n\n              case 2:\n                this.currentToken = _context3.sent;\n\n                if (this.refreshProactively) {\n                  this.scheduleRefresh();\n                }\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"refreshToken\",\n    value: function refreshToken(abortSignal) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n\n                if (!this.activeTokenFetching) {\n                  this.activeTokenFetching = this.refresh(abortSignal);\n                }\n\n                _context4.t0 = parseToken;\n                _context4.next = 5;\n                return this.activeTokenFetching;\n\n              case 5:\n                _context4.t1 = _context4.sent;\n                return _context4.abrupt(\"return\", (0, _context4.t0)(_context4.t1));\n\n              case 7:\n                _context4.prev = 7;\n                this.activeTokenFetching = null;\n                return _context4.finish(7);\n\n              case 10:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0,, 7, 10]]);\n      }));\n    }\n  }, {\n    key: \"scheduleRefresh\",\n    value: function scheduleRefresh() {\n      var _this = this;\n\n      if (this.disposed) {\n        return;\n      }\n\n      if (this.activeTimeout) {\n        clearTimeout(this.activeTimeout);\n      }\n\n      var timespanInMs = this.currentToken.expiresOnTimestamp - Date.now() - this.refreshingIntervalInMs;\n      this.activeTimeout = setTimeout(function () {\n        return _this.updateTokenAndReschedule();\n      }, timespanInMs);\n    }\n  }, {\n    key: \"isCurrentTokenValid\",\n    get: function get() {\n      return this.currentToken && Date.now() < this.currentToken.expiresOnTimestamp;\n    }\n  }, {\n    key: \"isCurrentTokenExpiringSoon\",\n    get: function get() {\n      return !this.currentToken || Date.now() >= this.currentToken.expiresOnTimestamp - this.refreshingIntervalInMs;\n    }\n  }]);\n\n  return AutoRefreshUserCredential;\n}();","map":{"version":3,"sources":["../../src/autoRefreshUserCredential.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike, AccessToken } from \"@azure/core-http\";\nimport { parseToken } from \"./tokenParser\";\nimport { UserCredential } from \"./communicationUserCredential\";\n\n/**\n * Options for auto-refreshing a Communication user credential.\n */\nexport interface RefreshOptions {\n  /**\n   * Function that returns a user token acquired from the Communication configuration SDK.\n   */\n  tokenRefresher: (abortSignal?: AbortSignalLike) => Promise<string>;\n\n  /**\n   * Optional user token to initialize.\n   */\n  initialToken?: string;\n\n  /**\n   * Indicates whether the user token should be proactively renewed prior to expiry or only renew on demand.\n   * By default false.\n   */\n  refreshProactively?: boolean;\n}\n\nconst expiredToken = { token: \"\", expiresOnTimestamp: -10 };\nconst minutesToMs = (minutes: number): number => minutes * 1000 * 60;\nconst defaultRefreshingInterval = minutesToMs(10);\n\nexport class AutoRefreshUserCredential implements UserCredential {\n  private readonly refresh: (abortSignal?: AbortSignalLike) => Promise<string>;\n  private readonly refreshProactively: boolean;\n  private readonly refreshingIntervalInMs: number = defaultRefreshingInterval;\n\n  private currentToken: AccessToken;\n  private activeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private activeTokenFetching: Promise<string> | null = null;\n  private activeTokenUpdating: Promise<void> | null = null;\n  private disposed = false;\n\n  constructor(refreshArgs: RefreshOptions) {\n    const { tokenRefresher, initialToken, refreshProactively } = refreshArgs;\n\n    this.refresh = tokenRefresher;\n    this.currentToken = initialToken ? parseToken(initialToken) : expiredToken;\n    this.refreshProactively = refreshProactively ?? false;\n\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  public async getToken(abortSignal?: AbortSignalLike): Promise<AccessToken> {\n    if (!this.isCurrentTokenExpiringSoon) {\n      return this.currentToken;\n    }\n\n    const updatePromise = this.updateTokenAndReschedule(abortSignal);\n\n    if (!this.isCurrentTokenValid) {\n      await updatePromise;\n    }\n\n    return this.currentToken;\n  }\n\n  public dispose(): void {\n    this.disposed = true;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.currentToken = expiredToken;\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n  }\n\n  private async updateTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    if (this.activeTokenUpdating) {\n      return this.activeTokenUpdating;\n    }\n    this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);\n    try {\n      await this.activeTokenUpdating;\n    } finally {\n      this.activeTokenUpdating = null;\n    }\n  }\n\n  private async refreshTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    this.currentToken = await this.refreshToken(abortSignal);\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  private async refreshToken(abortSignal?: AbortSignalLike): Promise<AccessToken> {\n    try {\n      if (!this.activeTokenFetching) {\n        this.activeTokenFetching = this.refresh(abortSignal);\n      }\n      return parseToken(await this.activeTokenFetching);\n    } finally {\n      this.activeTokenFetching = null;\n    }\n  }\n\n  private scheduleRefresh(): void {\n    if (this.disposed) {\n      return;\n    }\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n    const timespanInMs =\n      this.currentToken.expiresOnTimestamp - Date.now() - this.refreshingIntervalInMs;\n    this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);\n  }\n\n  private get isCurrentTokenValid(): boolean {\n    return this.currentToken && Date.now() < this.currentToken.expiresOnTimestamp;\n  }\n\n  private get isCurrentTokenExpiringSoon(): boolean {\n    return (\n      !this.currentToken ||\n      Date.now() >= this.currentToken.expiresOnTimestamp - this.refreshingIntervalInMs\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}