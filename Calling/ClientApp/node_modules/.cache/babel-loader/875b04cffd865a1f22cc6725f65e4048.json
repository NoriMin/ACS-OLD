{"ast":null,"code":"import _isEqual from \"lodash/isEqual\";\nimport { useIsomorphicLayoutEffect } from '@fluentui/react-bindings';\nimport { Ref, isRefObject } from '@fluentui/react-component-ref';\nimport * as PopperJs from '@popperjs/core';\nimport * as React from 'react';\nimport { isBrowser } from '../isBrowser';\nimport { getBoundary } from './getBoundary';\nimport { getScrollParent } from './getScrollParent';\nimport { getPlacement, applyRtlToOffset } from './positioningHelper';\n/**\n * Memoize a result using deep equality. This hook has two advantages over\n * React.useMemo: it uses deep equality to compare memo keys, and it guarantees\n * that the memo function will only be called if the keys are unequal.\n * React.useMemo cannot be relied on to do this, since it is only a performance\n * optimization (see https://reactjs.org/docs/hooks-reference.html#usememo).\n *\n * Copied from https://github.com/apollographql/react-apollo/blob/master/packages/hooks/src/utils/useDeepMemo.ts.\n */\n\nfunction useDeepMemo(memoFn, key) {\n  var ref = React.useRef();\n\n  if (!ref.current || !_isEqual(key, ref.current.key)) {\n    ref.current = {\n      key: key,\n      value: memoFn()\n    };\n  }\n\n  return ref.current.value;\n}\n/** Checks if components was mounted the first time. */\n\n\nfunction useFirstMount() {\n  var isFirst = React.useRef(true);\n\n  if (isFirst.current) {\n    isFirst.current = false;\n    return true;\n  }\n\n  return isFirst.current;\n}\n/** Executes useIsomorphicLayoutEffect during only updates. */\n\n\nvar useUpdateIsomorphicLayoutEffect = function useUpdateIsomorphicLayoutEffect(effect, deps) {\n  var isFirstMount = useFirstMount();\n  useIsomorphicLayoutEffect(function () {\n    if (!isFirstMount) {\n      return effect();\n    }\n  }, deps);\n};\n/**\n * Popper relies on the 3rd party library [Popper.js](https://github.com/FezVrasta/popper.js) for positioning.\n */\n\n\nexport var Popper = /*#__PURE__*/function () {\n  var Popper = function Popper(props) {\n    var align = props.align,\n        children = props.children,\n        enabled = props.enabled,\n        flipBoundary = props.flipBoundary,\n        userModifiers = props.modifiers,\n        offset = props.offset,\n        overflowBoundary = props.overflowBoundary,\n        pointerTargetRef = props.pointerTargetRef,\n        popperRef = props.popperRef,\n        position = props.position,\n        positionFixed = props.positionFixed,\n        _props$positioningDep = props.positioningDependencies,\n        positioningDependencies = _props$positioningDep === void 0 ? [] : _props$positioningDep,\n        rtl = props.rtl,\n        targetRef = props.targetRef,\n        unstable_pinned = props.unstable_pinned;\n    var proposedPlacement = getPlacement({\n      align: align,\n      position: position,\n      rtl: rtl\n    });\n    var popperInstanceRef = React.useRef();\n    var contentRef = React.useRef(null);\n    var latestPlacement = React.useRef(proposedPlacement);\n\n    var _React$useState = React.useState(proposedPlacement),\n        computedPlacement = _React$useState[0],\n        setComputedPlacement = _React$useState[1];\n\n    var computedModifiers = useDeepMemo(function () {\n      return [offset && {\n        name: 'offset',\n        options: {\n          offset: rtl ? applyRtlToOffset(offset) : offset\n        }\n      }].concat(userModifiers);\n    }, [offset, flipBoundary, overflowBoundary, userModifiers]);\n    var createInstance = React.useCallback(function () {\n      var reference = targetRef && isRefObject(targetRef) ? targetRef.current : targetRef;\n\n      if (!enabled || !reference || !contentRef.current) {\n        return;\n      }\n\n      var handleUpdate = function handleUpdate(_ref) {\n        var state = _ref.state; // PopperJS performs computations that might update the computed placement: auto positioning, flipping the\n        // placement in case the popper box should be rendered at the edge of the viewport and does not fit\n\n        if (state.placement !== latestPlacement.current) {\n          latestPlacement.current = state.placement;\n          setComputedPlacement(state.placement);\n        }\n      };\n\n      var hasDocument = isBrowser();\n      var scrollParentElement = hasDocument ? getScrollParent(contentRef.current) : null;\n      var hasScrollableElement = scrollParentElement ? scrollParentElement !== scrollParentElement.ownerDocument.body : false;\n      var hasPointer = !!(pointerTargetRef && pointerTargetRef.current);\n      var modifiers = [{\n        name: 'flip',\n        options: {\n          flipVariations: true\n        }\n      },\n      /**\n       * unstable_pinned disables the flip modifier by setting flip.enabled to false; this\n       * disables automatic repositioning of the popper box; it will always be placed according to\n       * the values of `align` and `position` props, regardless of the size of the component, the\n       * reference element or the viewport.\n       */\n      unstable_pinned && {\n        name: 'flip',\n        enabled: false\n      },\n      /**\n       * When the popper box is placed in the context of a scrollable element, we need to set\n       * preventOverflow.escapeWithReference to true and flip.boundariesElement to 'scrollParent'\n       * (default is 'viewport') so that the popper box will stick with the targetRef when we\n       * scroll targetRef out of the viewport.\n       */\n      hasScrollableElement && {\n        name: 'flip',\n        options: {\n          boundary: 'clippingParents'\n        }\n      }, hasScrollableElement && {\n        name: 'preventOverflow',\n        options: {\n          boundary: 'clippingParents'\n        }\n      }];\n      var options = {\n        placement: proposedPlacement,\n        strategy: positionFixed ? 'fixed' : 'absolute',\n        modifiers: [].concat(modifiers, computedModifiers, [\n        /**\n         * This modifier is necessary in order to render the pointer. Refs are resolved in effects, so it can't be\n         * placed under computed modifiers. Deep merge is not required as this modifier has only these properties.\n         */\n        {\n          name: 'arrow',\n          enabled: hasPointer,\n          options: {\n            element: pointerTargetRef && pointerTargetRef.current\n          }\n        }, flipBoundary && {\n          name: 'flip',\n          options: {\n            altBoundary: true,\n            boundary: getBoundary(contentRef.current, flipBoundary)\n          }\n        }, overflowBoundary && {\n          name: 'preventOverflow',\n          options: {\n            altBoundary: true,\n            boundary: getBoundary(contentRef.current, overflowBoundary)\n          }\n        }, {\n          name: 'onUpdate',\n          enabled: true,\n          phase: 'afterWrite',\n          fn: handleUpdate\n        }]).filter(Boolean),\n        onFirstUpdate: function onFirstUpdate(state) {\n          return handleUpdate({\n            state: state\n          });\n        }\n      };\n      popperInstanceRef.current = PopperJs.createPopper(reference, contentRef.current, options);\n    }, [contentRef, computedModifiers, enabled, flipBoundary, overflowBoundary, pointerTargetRef, positionFixed, proposedPlacement, targetRef, unstable_pinned]);\n    var destroyInstance = React.useCallback(function () {\n      if (popperInstanceRef.current) {\n        popperInstanceRef.current.destroy();\n        popperInstanceRef.current = null;\n      }\n    }, []);\n    var scheduleUpdate = React.useCallback(function () {\n      if (popperInstanceRef.current) {\n        popperInstanceRef.current.update();\n      }\n    }, []);\n    React.useImperativeHandle(popperRef, function () {\n      return {\n        updatePosition: scheduleUpdate\n      };\n    }, [scheduleUpdate]);\n    useIsomorphicLayoutEffect(function () {\n      createInstance();\n      return destroyInstance;\n    }, [createInstance]);\n    useUpdateIsomorphicLayoutEffect(scheduleUpdate, [].concat(positioningDependencies, [computedPlacement]));\n    var child = typeof children === 'function' ? children({\n      placement: computedPlacement,\n      scheduleUpdate: scheduleUpdate\n    }) : children;\n    return child ? /*#__PURE__*/React.createElement(Ref, {\n      innerRef: contentRef\n    }, React.Children.only(child)) : null;\n  };\n\n  Popper.defaultProps = {\n    enabled: true,\n    modifiers: [],\n    positionFixed: false,\n    positioningDependencies: []\n  };\n  return Popper;\n}();","map":{"version":3,"sources":["utils/positioner/Popper.tsx"],"names":["ref","React","key","value","memoFn","isFirst","useUpdateIsomorphicLayoutEffect","isFirstMount","useFirstMount","useIsomorphicLayoutEffect","effect","Popper","align","children","enabled","flipBoundary","userModifiers","offset","overflowBoundary","pointerTargetRef","popperRef","position","positionFixed","positioningDependencies","rtl","targetRef","unstable_pinned","props","proposedPlacement","getPlacement","popperInstanceRef","contentRef","latestPlacement","computedPlacement","setComputedPlacement","computedModifiers","useDeepMemo","name","options","applyRtlToOffset","createInstance","reference","isRefObject","handleUpdate","state","hasDocument","isBrowser","scrollParentElement","getScrollParent","hasScrollableElement","hasPointer","modifiers","flipVariations","boundary","placement","strategy","element","current","altBoundary","getBoundary","phase","fn","onFirstUpdate","PopperJs","destroyInstance","scheduleUpdate","updatePosition","child"],"mappings":"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","sourcesContent":["import { useIsomorphicLayoutEffect } from '@fluentui/react-bindings';\nimport { Ref, isRefObject } from '@fluentui/react-component-ref';\nimport * as PopperJs from '@popperjs/core';\nimport * as _ from 'lodash';\nimport * as React from 'react';\n\nimport { isBrowser } from '../isBrowser';\nimport { getBoundary } from './getBoundary';\nimport { getScrollParent } from './getScrollParent';\nimport { getPlacement, applyRtlToOffset } from './positioningHelper';\nimport { PopperModifiers, PopperProps } from './types';\n\n/**\n * Memoize a result using deep equality. This hook has two advantages over\n * React.useMemo: it uses deep equality to compare memo keys, and it guarantees\n * that the memo function will only be called if the keys are unequal.\n * React.useMemo cannot be relied on to do this, since it is only a performance\n * optimization (see https://reactjs.org/docs/hooks-reference.html#usememo).\n *\n * Copied from https://github.com/apollographql/react-apollo/blob/master/packages/hooks/src/utils/useDeepMemo.ts.\n */\nfunction useDeepMemo<TKey, TValue>(memoFn: () => TValue, key: TKey): TValue {\n  const ref = React.useRef<{ key: TKey; value: TValue }>();\n\n  if (!ref.current || !_.isEqual(key, ref.current.key)) {\n    ref.current = { key, value: memoFn() };\n  }\n\n  return ref.current.value;\n}\n\n/** Checks if components was mounted the first time. */\nfunction useFirstMount(): boolean {\n  const isFirst = React.useRef(true);\n\n  if (isFirst.current) {\n    isFirst.current = false;\n    return true;\n  }\n\n  return isFirst.current;\n}\n\n/** Executes useIsomorphicLayoutEffect during only updates. */\nconst useUpdateIsomorphicLayoutEffect: typeof React.useLayoutEffect = (effect, deps) => {\n  const isFirstMount = useFirstMount();\n\n  useIsomorphicLayoutEffect(() => {\n    if (!isFirstMount) {\n      return effect();\n    }\n  }, deps);\n};\n\n/**\n * Popper relies on the 3rd party library [Popper.js](https://github.com/FezVrasta/popper.js) for positioning.\n */\nexport const Popper: React.FunctionComponent<PopperProps> = props => {\n  const {\n    align,\n    children,\n    enabled,\n    flipBoundary,\n    modifiers: userModifiers,\n    offset,\n    overflowBoundary,\n    pointerTargetRef,\n    popperRef,\n    position,\n    positionFixed,\n    positioningDependencies = [],\n    rtl,\n    targetRef,\n    unstable_pinned,\n  } = props;\n\n  const proposedPlacement = getPlacement({ align, position, rtl });\n\n  const popperInstanceRef = React.useRef<PopperJs.Instance>();\n  const contentRef = React.useRef<HTMLElement>(null);\n\n  const latestPlacement = React.useRef<PopperJs.Placement>(proposedPlacement);\n  const [computedPlacement, setComputedPlacement] = React.useState<PopperJs.Placement>(proposedPlacement);\n\n  const computedModifiers = useDeepMemo<any, PopperModifiers>(\n    () => [\n      offset && {\n        name: 'offset',\n        options: { offset: rtl ? applyRtlToOffset(offset) : offset },\n      },\n      ...userModifiers,\n    ],\n    [offset, flipBoundary, overflowBoundary, userModifiers],\n  );\n\n  const createInstance = React.useCallback(() => {\n    const reference: Element | PopperJs.VirtualElement =\n      targetRef && isRefObject(targetRef)\n        ? (targetRef as React.RefObject<Element>).current\n        : (targetRef as PopperJs.VirtualElement);\n\n    if (!enabled || !reference || !contentRef.current) {\n      return;\n    }\n\n    const handleUpdate = ({ state }: { state: Partial<PopperJs.State> }) => {\n      // PopperJS performs computations that might update the computed placement: auto positioning, flipping the\n      // placement in case the popper box should be rendered at the edge of the viewport and does not fit\n      if (state.placement !== latestPlacement.current) {\n        latestPlacement.current = state.placement;\n        setComputedPlacement(state.placement);\n      }\n    };\n\n    const hasDocument = isBrowser();\n    const scrollParentElement: Node | null = hasDocument ? getScrollParent(contentRef.current) : null;\n\n    const hasScrollableElement = scrollParentElement\n      ? scrollParentElement !== scrollParentElement.ownerDocument.body\n      : false;\n    const hasPointer = !!(pointerTargetRef && pointerTargetRef.current);\n\n    const modifiers: PopperModifiers = [\n      { name: 'flip', options: { flipVariations: true } },\n\n      /**\n       * unstable_pinned disables the flip modifier by setting flip.enabled to false; this\n       * disables automatic repositioning of the popper box; it will always be placed according to\n       * the values of `align` and `position` props, regardless of the size of the component, the\n       * reference element or the viewport.\n       */\n      unstable_pinned && { name: 'flip', enabled: false },\n\n      /**\n       * When the popper box is placed in the context of a scrollable element, we need to set\n       * preventOverflow.escapeWithReference to true and flip.boundariesElement to 'scrollParent'\n       * (default is 'viewport') so that the popper box will stick with the targetRef when we\n       * scroll targetRef out of the viewport.\n       */\n      hasScrollableElement && { name: 'flip', options: { boundary: 'clippingParents' } },\n      hasScrollableElement && { name: 'preventOverflow', options: { boundary: 'clippingParents' } },\n    ];\n\n    const options: PopperJs.Options = {\n      placement: proposedPlacement,\n      strategy: positionFixed ? 'fixed' : 'absolute',\n      modifiers: [\n        ...(modifiers as PopperJs.Options['modifiers']),\n\n        ...computedModifiers,\n\n        /**\n         * This modifier is necessary in order to render the pointer. Refs are resolved in effects, so it can't be\n         * placed under computed modifiers. Deep merge is not required as this modifier has only these properties.\n         */\n        {\n          name: 'arrow',\n          enabled: hasPointer,\n          options: {\n            element: pointerTargetRef && pointerTargetRef.current,\n          },\n        },\n\n        flipBoundary && {\n          name: 'flip',\n          options: {\n            altBoundary: true,\n            boundary: getBoundary(contentRef.current, flipBoundary),\n          },\n        },\n        overflowBoundary && {\n          name: 'preventOverflow',\n          options: {\n            altBoundary: true,\n            boundary: getBoundary(contentRef.current, overflowBoundary),\n          },\n        },\n\n        {\n          name: 'onUpdate',\n          enabled: true,\n          phase: 'afterWrite' as PopperJs.ModifierPhases,\n          fn: handleUpdate,\n        },\n      ].filter(Boolean),\n      onFirstUpdate: state => handleUpdate({ state }),\n    };\n\n    popperInstanceRef.current = PopperJs.createPopper(reference, contentRef.current, options);\n  }, [\n    contentRef,\n    computedModifiers,\n    enabled,\n    flipBoundary,\n    overflowBoundary,\n    pointerTargetRef,\n    positionFixed,\n    proposedPlacement,\n    targetRef,\n    unstable_pinned,\n  ]);\n\n  const destroyInstance = React.useCallback(() => {\n    if (popperInstanceRef.current) {\n      popperInstanceRef.current.destroy();\n      popperInstanceRef.current = null;\n    }\n  }, []);\n\n  const scheduleUpdate = React.useCallback(() => {\n    if (popperInstanceRef.current) {\n      popperInstanceRef.current.update();\n    }\n  }, []);\n\n  React.useImperativeHandle(\n    popperRef,\n    () => ({\n      updatePosition: scheduleUpdate,\n    }),\n    [scheduleUpdate],\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    createInstance();\n    return destroyInstance;\n  }, [createInstance]);\n\n  useUpdateIsomorphicLayoutEffect(scheduleUpdate, [...positioningDependencies, computedPlacement]);\n\n  const child =\n    typeof children === 'function'\n      ? children({ placement: computedPlacement, scheduleUpdate })\n      : (children as React.ReactElement);\n\n  return child ? <Ref innerRef={contentRef}>{React.Children.only(child)}</Ref> : null;\n};\n\nPopper.defaultProps = {\n  enabled: true,\n  modifiers: [],\n  positionFixed: false,\n  positioningDependencies: [],\n};\n"]},"metadata":{},"sourceType":"module"}