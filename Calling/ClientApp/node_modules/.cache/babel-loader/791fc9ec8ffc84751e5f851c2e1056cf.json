{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { __read, __spread, __values } from \"tslib\";\nimport debug from \"./debug\";\nvar registeredLoggers = new Set();\nvar logLevelFromEnv = typeof process !== \"undefined\" && process.env && process.env.AZURE_LOG_LEVEL || undefined;\nvar azureLogLevel;\n/**\n * The AzureLogger provides a mechanism for overriding where logs are output to.\n * By default, logs are sent to stderr.\n * Override the `log` method to redirect logs to another location.\n */\n\nexport var AzureLogger = debug(\"azure\");\n\nAzureLogger.log = function () {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  debug.log.apply(debug, __spread(args));\n};\n\nvar AZURE_LOG_LEVELS = [\"verbose\", \"info\", \"warning\", \"error\"];\n\nif (logLevelFromEnv) {\n  // avoid calling setLogLevel because we don't want a mis-set environment variable to crash\n  if (isAzureLogLevel(logLevelFromEnv)) {\n    setLogLevel(logLevelFromEnv);\n  } else {\n    console.error(\"AZURE_LOG_LEVEL set to unknown log level '\" + logLevelFromEnv + \"'; logging is not enabled. Acceptable values: \" + AZURE_LOG_LEVELS.join(\", \") + \".\");\n  }\n}\n/**\n * Immediately enables logging at the specified log level.\n * @param level The log level to enable for logging.\n * Options from most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\n\n\nexport function setLogLevel(level) {\n  var e_1, _a;\n\n  if (level && !isAzureLogLevel(level)) {\n    throw new Error(\"Unknown log level '\" + level + \"'. Acceptable values: \" + AZURE_LOG_LEVELS.join(\",\"));\n  }\n\n  azureLogLevel = level;\n  var enabledNamespaces = [];\n\n  try {\n    for (var registeredLoggers_1 = __values(registeredLoggers), registeredLoggers_1_1 = registeredLoggers_1.next(); !registeredLoggers_1_1.done; registeredLoggers_1_1 = registeredLoggers_1.next()) {\n      var logger = registeredLoggers_1_1.value;\n\n      if (shouldEnable(logger)) {\n        enabledNamespaces.push(logger.namespace);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (registeredLoggers_1_1 && !registeredLoggers_1_1.done && (_a = registeredLoggers_1.return)) _a.call(registeredLoggers_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  debug.enable(enabledNamespaces.join(\",\"));\n}\n/**\n * Retrieves the currently specified log level.\n */\n\nexport function getLogLevel() {\n  return azureLogLevel;\n}\nvar levelMap = {\n  verbose: 400,\n  info: 300,\n  warning: 200,\n  error: 100\n};\n/**\n * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.\n * @param namespace The name of the SDK package.\n * @ignore\n */\n\nexport function createClientLogger(namespace) {\n  var clientRootLogger = AzureLogger.extend(namespace);\n  patchLogMethod(AzureLogger, clientRootLogger);\n  return {\n    error: createLogger(clientRootLogger, \"error\"),\n    warning: createLogger(clientRootLogger, \"warning\"),\n    info: createLogger(clientRootLogger, \"info\"),\n    verbose: createLogger(clientRootLogger, \"verbose\")\n  };\n}\n\nfunction patchLogMethod(parent, child) {\n  child.log = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    parent.log.apply(parent, __spread(args));\n  };\n}\n\nfunction createLogger(parent, level) {\n  var logger = Object.assign(parent.extend(level), {\n    level: level\n  });\n  patchLogMethod(parent, logger);\n\n  if (shouldEnable(logger)) {\n    var enabledNamespaces = debug.disable();\n    debug.enable(enabledNamespaces + \",\" + logger.namespace);\n  }\n\n  registeredLoggers.add(logger);\n  return logger;\n}\n\nfunction shouldEnable(logger) {\n  if (azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction isAzureLogLevel(logLevel) {\n  return AZURE_LOG_LEVELS.includes(logLevel);\n}","map":{"version":3,"sources":["../../src/logger.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { __read, __spread, __values } from \"tslib\";\nimport debug from \"./debug\";\nvar registeredLoggers = new Set();\nvar logLevelFromEnv = (typeof process !== \"undefined\" && process.env && process.env.AZURE_LOG_LEVEL) || undefined;\nvar azureLogLevel;\n/**\n * The AzureLogger provides a mechanism for overriding where logs are output to.\n * By default, logs are sent to stderr.\n * Override the `log` method to redirect logs to another location.\n */\nexport var AzureLogger = debug(\"azure\");\nAzureLogger.log = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    debug.log.apply(debug, __spread(args));\n};\nvar AZURE_LOG_LEVELS = [\"verbose\", \"info\", \"warning\", \"error\"];\nif (logLevelFromEnv) {\n    // avoid calling setLogLevel because we don't want a mis-set environment variable to crash\n    if (isAzureLogLevel(logLevelFromEnv)) {\n        setLogLevel(logLevelFromEnv);\n    }\n    else {\n        console.error(\"AZURE_LOG_LEVEL set to unknown log level '\" + logLevelFromEnv + \"'; logging is not enabled. Acceptable values: \" + AZURE_LOG_LEVELS.join(\", \") + \".\");\n    }\n}\n/**\n * Immediately enables logging at the specified log level.\n * @param level The log level to enable for logging.\n * Options from most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\nexport function setLogLevel(level) {\n    var e_1, _a;\n    if (level && !isAzureLogLevel(level)) {\n        throw new Error(\"Unknown log level '\" + level + \"'. Acceptable values: \" + AZURE_LOG_LEVELS.join(\",\"));\n    }\n    azureLogLevel = level;\n    var enabledNamespaces = [];\n    try {\n        for (var registeredLoggers_1 = __values(registeredLoggers), registeredLoggers_1_1 = registeredLoggers_1.next(); !registeredLoggers_1_1.done; registeredLoggers_1_1 = registeredLoggers_1.next()) {\n            var logger = registeredLoggers_1_1.value;\n            if (shouldEnable(logger)) {\n                enabledNamespaces.push(logger.namespace);\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (registeredLoggers_1_1 && !registeredLoggers_1_1.done && (_a = registeredLoggers_1.return)) _a.call(registeredLoggers_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    debug.enable(enabledNamespaces.join(\",\"));\n}\n/**\n * Retrieves the currently specified log level.\n */\nexport function getLogLevel() {\n    return azureLogLevel;\n}\nvar levelMap = {\n    verbose: 400,\n    info: 300,\n    warning: 200,\n    error: 100\n};\n/**\n * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.\n * @param namespace The name of the SDK package.\n * @ignore\n */\nexport function createClientLogger(namespace) {\n    var clientRootLogger = AzureLogger.extend(namespace);\n    patchLogMethod(AzureLogger, clientRootLogger);\n    return {\n        error: createLogger(clientRootLogger, \"error\"),\n        warning: createLogger(clientRootLogger, \"warning\"),\n        info: createLogger(clientRootLogger, \"info\"),\n        verbose: createLogger(clientRootLogger, \"verbose\")\n    };\n}\nfunction patchLogMethod(parent, child) {\n    child.log = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        parent.log.apply(parent, __spread(args));\n    };\n}\nfunction createLogger(parent, level) {\n    var logger = Object.assign(parent.extend(level), {\n        level: level\n    });\n    patchLogMethod(parent, logger);\n    if (shouldEnable(logger)) {\n        var enabledNamespaces = debug.disable();\n        debug.enable(enabledNamespaces + \",\" + logger.namespace);\n    }\n    registeredLoggers.add(logger);\n    return logger;\n}\nfunction shouldEnable(logger) {\n    if (azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nfunction isAzureLogLevel(logLevel) {\n    return AZURE_LOG_LEVELS.includes(logLevel);\n}\n//# sourceMappingURL=logger.js.map"]},"metadata":{},"sourceType":"module"}