{"ast":null,"code":"var listenersMap = new WeakMap();\nvar abortedMap = new WeakMap();\n/**\n * An aborter instance implements AbortSignal interface, can abort HTTP requests.\n *\n * - Call AbortSignal.none to create a new AbortSignal instance that cannot be cancelled.\n * Use `AbortSignal.none` when you are required to pass a cancellation token but the operation\n * cannot or will not ever be cancelled.\n *\n * @example\n * // Abort without timeout\n * await doAsyncWork(AbortSignal.none);\n *\n * @export\n * @class AbortSignal\n * @implements {AbortSignalLike}\n */\n\nvar AbortSignal =\n/** @class */\nfunction () {\n  function AbortSignal() {\n    /**\n     * onabort event listener.\n     *\n     * @memberof AbortSignal\n     */\n    this.onabort = null;\n    listenersMap.set(this, []);\n    abortedMap.set(this, false);\n  }\n\n  Object.defineProperty(AbortSignal.prototype, \"aborted\", {\n    /**\n     * Status of whether aborted or not.\n     *\n     * @readonly\n     * @type {boolean}\n     * @memberof AbortSignal\n     */\n    get: function get() {\n      if (!abortedMap.has(this)) {\n        throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n      }\n\n      return abortedMap.get(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AbortSignal, \"none\", {\n    /**\n     * Creates a new AbortSignal instance that will never be aborted.\n     *\n     * @readonly\n     * @static\n     * @type {AbortSignal}\n     * @memberof AbortSignal\n     */\n    get: function get() {\n      return new AbortSignal();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Added new \"abort\" event listener, only support \"abort\" event.\n   *\n   * @param {\"abort\"} _type Only support \"abort\" event\n   * @param {(this: AbortSignalLike, ev: any) => any} listener\n   * @memberof AbortSignal\n   */\n\n  AbortSignal.prototype.addEventListener = function ( // tslint:disable-next-line:variable-name\n  _type, listener) {\n    if (!listenersMap.has(this)) {\n      throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n    }\n\n    var listeners = listenersMap.get(this);\n    listeners.push(listener);\n  };\n  /**\n   * Remove \"abort\" event listener, only support \"abort\" event.\n   *\n   * @param {\"abort\"} _type Only support \"abort\" event\n   * @param {(this: AbortSignalLike, ev: any) => any} listener\n   * @memberof AbortSignal\n   */\n\n\n  AbortSignal.prototype.removeEventListener = function ( // tslint:disable-next-line:variable-name\n  _type, listener) {\n    if (!listenersMap.has(this)) {\n      throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n    }\n\n    var listeners = listenersMap.get(this);\n    var index = listeners.indexOf(listener);\n\n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n  };\n  /**\n   * Dispatches a synthetic event to the AbortSignal.\n   */\n\n\n  AbortSignal.prototype.dispatchEvent = function (_event) {\n    throw new Error(\"This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.\");\n  };\n\n  return AbortSignal;\n}();\n\nexport { AbortSignal };\n/**\n * Helper to trigger an abort event immediately, the onabort and all abort event listeners will be triggered.\n * Will try to trigger abort event for all linked AbortSignal nodes.\n *\n * - If there is a timeout, the timer will be cancelled.\n * - If aborted is true, nothing will happen.\n *\n * @returns\n * @internal\n */\n\nexport function abortSignal(signal) {\n  if (signal.aborted) {\n    return;\n  }\n\n  if (signal.onabort) {\n    signal.onabort.call(signal);\n  }\n\n  var listeners = listenersMap.get(signal);\n\n  if (listeners) {\n    listeners.forEach(function (listener) {\n      listener.call(signal, {\n        type: \"abort\"\n      });\n    });\n  }\n\n  abortedMap.set(signal, true);\n}","map":{"version":3,"sources":["../../src/AbortSignal.ts"],"names":[],"mappings":"AAGA,IAAM,YAAY,GAAG,IAAI,OAAJ,EAArB;AACA,IAAM,UAAU,GAAG,IAAI,OAAJ,EAAnB;AA6BA;;;;;;;;;;;;;;;;AAeA,IAAA,WAAA;AAAA;AAAA,YAAA;AACE,WAAA,WAAA,GAAA;AAgCA;;;;;AAKO,SAAA,OAAA,GAAwC,IAAxC;AApCL,IAAA,YAAY,CAAC,GAAb,CAAiB,IAAjB,EAAuB,EAAvB;AACA,IAAA,UAAU,CAAC,GAAX,CAAe,IAAf,EAAqB,KAArB;AACD;;AASD,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,SAAX,EAAkB;AAPlB;;;;;;;SAOA,eAAA;AACE,UAAI,CAAC,UAAU,CAAC,GAAX,CAAe,IAAf,CAAL,EAA2B;AACzB,cAAM,IAAI,SAAJ,CAAc,mDAAd,CAAN;AACD;;AAED,aAAO,UAAU,CAAC,GAAX,CAAe,IAAf,CAAP;AACD,KANiB;oBAAA;;AAAA,GAAlB;AAgBA,EAAA,MAAA,CAAA,cAAA,CAAkB,WAAlB,EAAkB,MAAlB,EAAsB;AARtB;;;;;;;;SAQA,eAAA;AACE,aAAO,IAAI,WAAJ,EAAP;AACD,KAFqB;oBAAA;;AAAA,GAAtB;AAWA;;;;;;;;AAOO,EAAA,WAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,WACE;AACA,EAAA,KAFF,EAGE,QAHF,EAGmD;AAEjD,QAAI,CAAC,YAAY,CAAC,GAAb,CAAiB,IAAjB,CAAL,EAA6B;AAC3B,YAAM,IAAI,SAAJ,CAAc,mDAAd,CAAN;AACD;;AAED,QAAM,SAAS,GAAG,YAAY,CAAC,GAAb,CAAiB,IAAjB,CAAlB;AACA,IAAA,SAAS,CAAC,IAAV,CAAe,QAAf;AACD,GAXM;AAaP;;;;;;;;;AAOO,EAAA,WAAA,CAAA,SAAA,CAAA,mBAAA,GAAP,WACE;AACA,EAAA,KAFF,EAGE,QAHF,EAGmD;AAEjD,QAAI,CAAC,YAAY,CAAC,GAAb,CAAiB,IAAjB,CAAL,EAA6B;AAC3B,YAAM,IAAI,SAAJ,CAAc,mDAAd,CAAN;AACD;;AAED,QAAM,SAAS,GAAG,YAAY,CAAC,GAAb,CAAiB,IAAjB,CAAlB;AAEA,QAAM,KAAK,GAAG,SAAS,CAAC,OAAV,CAAkB,QAAlB,CAAd;;AACA,QAAI,KAAK,GAAG,CAAC,CAAb,EAAgB;AACd,MAAA,SAAS,CAAC,MAAV,CAAiB,KAAjB,EAAwB,CAAxB;AACD;AACF,GAfM;AAiBP;;;;;AAGA,EAAA,WAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,MAAd,EAA2B;AACzB,UAAM,IAAI,KAAJ,CACJ,kHADI,CAAN;AAGD,GAJD;;AAKF,SAAA,WAAA;AAAC,CA5FD,EAAA;;;AA8FA;;;;;;;;;;;AAUA,OAAM,SAAU,WAAV,CAAsB,MAAtB,EAAyC;AAC7C,MAAI,MAAM,CAAC,OAAX,EAAoB;AAClB;AACD;;AAED,MAAI,MAAM,CAAC,OAAX,EAAoB;AAClB,IAAA,MAAM,CAAC,OAAP,CAAe,IAAf,CAAoB,MAApB;AACD;;AAED,MAAM,SAAS,GAAG,YAAY,CAAC,GAAb,CAAiB,MAAjB,CAAlB;;AACA,MAAI,SAAJ,EAAe;AACb,IAAA,SAAS,CAAC,OAAV,CAAkB,UAAC,QAAD,EAAS;AACzB,MAAA,QAAQ,CAAC,IAAT,CAAc,MAAd,EAAsB;AAAE,QAAA,IAAI,EAAE;AAAR,OAAtB;AACD,KAFD;AAGD;;AAED,EAAA,UAAU,CAAC,GAAX,CAAe,MAAf,EAAuB,IAAvB;AACD","sourceRoot":"","sourcesContent":["var listenersMap = new WeakMap();\nvar abortedMap = new WeakMap();\n/**\n * An aborter instance implements AbortSignal interface, can abort HTTP requests.\n *\n * - Call AbortSignal.none to create a new AbortSignal instance that cannot be cancelled.\n * Use `AbortSignal.none` when you are required to pass a cancellation token but the operation\n * cannot or will not ever be cancelled.\n *\n * @example\n * // Abort without timeout\n * await doAsyncWork(AbortSignal.none);\n *\n * @export\n * @class AbortSignal\n * @implements {AbortSignalLike}\n */\nvar AbortSignal = /** @class */ (function () {\n    function AbortSignal() {\n        /**\n         * onabort event listener.\n         *\n         * @memberof AbortSignal\n         */\n        this.onabort = null;\n        listenersMap.set(this, []);\n        abortedMap.set(this, false);\n    }\n    Object.defineProperty(AbortSignal.prototype, \"aborted\", {\n        /**\n         * Status of whether aborted or not.\n         *\n         * @readonly\n         * @type {boolean}\n         * @memberof AbortSignal\n         */\n        get: function () {\n            if (!abortedMap.has(this)) {\n                throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n            }\n            return abortedMap.get(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AbortSignal, \"none\", {\n        /**\n         * Creates a new AbortSignal instance that will never be aborted.\n         *\n         * @readonly\n         * @static\n         * @type {AbortSignal}\n         * @memberof AbortSignal\n         */\n        get: function () {\n            return new AbortSignal();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Added new \"abort\" event listener, only support \"abort\" event.\n     *\n     * @param {\"abort\"} _type Only support \"abort\" event\n     * @param {(this: AbortSignalLike, ev: any) => any} listener\n     * @memberof AbortSignal\n     */\n    AbortSignal.prototype.addEventListener = function (\n    // tslint:disable-next-line:variable-name\n    _type, listener) {\n        if (!listenersMap.has(this)) {\n            throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n        }\n        var listeners = listenersMap.get(this);\n        listeners.push(listener);\n    };\n    /**\n     * Remove \"abort\" event listener, only support \"abort\" event.\n     *\n     * @param {\"abort\"} _type Only support \"abort\" event\n     * @param {(this: AbortSignalLike, ev: any) => any} listener\n     * @memberof AbortSignal\n     */\n    AbortSignal.prototype.removeEventListener = function (\n    // tslint:disable-next-line:variable-name\n    _type, listener) {\n        if (!listenersMap.has(this)) {\n            throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n        }\n        var listeners = listenersMap.get(this);\n        var index = listeners.indexOf(listener);\n        if (index > -1) {\n            listeners.splice(index, 1);\n        }\n    };\n    /**\n     * Dispatches a synthetic event to the AbortSignal.\n     */\n    AbortSignal.prototype.dispatchEvent = function (_event) {\n        throw new Error(\"This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.\");\n    };\n    return AbortSignal;\n}());\nexport { AbortSignal };\n/**\n * Helper to trigger an abort event immediately, the onabort and all abort event listeners will be triggered.\n * Will try to trigger abort event for all linked AbortSignal nodes.\n *\n * - If there is a timeout, the timer will be cancelled.\n * - If aborted is true, nothing will happen.\n *\n * @returns\n * @internal\n */\nexport function abortSignal(signal) {\n    if (signal.aborted) {\n        return;\n    }\n    if (signal.onabort) {\n        signal.onabort.call(signal);\n    }\n    var listeners = listenersMap.get(signal);\n    if (listeners) {\n        listeners.forEach(function (listener) {\n            listener.call(signal, { type: \"abort\" });\n        });\n    }\n    abortedMap.set(signal, true);\n}\n//# sourceMappingURL=AbortSignal.js.map"]},"metadata":{},"sourceType":"module"}