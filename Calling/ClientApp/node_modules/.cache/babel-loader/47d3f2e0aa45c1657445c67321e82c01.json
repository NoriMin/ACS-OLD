{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __assign, __awaiter, __generator, __spreadArrays } from \"tslib\";\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { DefaultHttpClient } from \"./defaultHttpClient\";\nimport { logPolicy } from \"./policies/logPolicy\";\nimport { getPathStringFromParameter, getPathStringFromParameterPath } from \"./operationParameter\";\nimport { isStreamOperation } from \"./operationSpec\";\nimport { deserializationPolicy, DefaultDeserializationOptions } from \"./policies/deserializationPolicy\";\nimport { exponentialRetryPolicy, DefaultRetryOptions } from \"./policies/exponentialRetryPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport { userAgentPolicy, getDefaultUserAgentHeaderName, getDefaultUserAgentValue } from \"./policies/userAgentPolicy\";\nimport { redirectPolicy, DefaultRedirectOptions } from \"./policies/redirectPolicy\";\nimport { RequestPolicyOptions } from \"./policies/requestPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { MapperType } from \"./serializer\";\nimport { URLBuilder } from \"./url\";\nimport * as utils from \"./util/utils\";\nimport { stringifyXML } from \"./util/xml\";\nimport { WebResource, isWebResourceLike } from \"./webResource\";\nimport { isNode } from \"./util/utils\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { logger } from \"./log\";\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from \"./policies/keepAlivePolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\nimport { disableResponseDecompressionPolicy } from \"./policies/disableResponseDecompressionPolicy\";\n/**\n * @class\n * Initializes a new instance of the ServiceClient.\n */\n\nvar ServiceClient =\n/** @class */\nfunction () {\n  /**\n   * The ServiceClient constructor\n   * @constructor\n   * @param credentials The credentials used for authentication with the service.\n   * @param options The service client options that govern the behavior of the client.\n   */\n  function ServiceClient(credentials,\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n  options) {\n    var _this = this;\n\n    if (!options) {\n      options = {};\n    }\n\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || new DefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n    var requestPolicyFactories;\n\n    if (Array.isArray(options.requestPolicyFactories)) {\n      logger.info(\"ServiceClient: using custom request policies\");\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      var authPolicyFactory = undefined;\n\n      if (isTokenCredential(credentials)) {\n        logger.info(\"ServiceClient: creating bearer token authentication policy from provided credentials\"); // Create a wrapped RequestPolicyFactory here so that we can provide the\n        // correct scope to the BearerTokenAuthenticationPolicy at the first time\n        // one is requested.  This is needed because generated ServiceClient\n        // implementations do not set baseUri until after ServiceClient's constructor\n        // is finished, leaving baseUri empty at the time when it is needed to\n        // build the correct scope name.\n\n        var wrappedPolicyFactory = function wrappedPolicyFactory() {\n          var bearerTokenPolicyFactory = undefined; // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n          var serviceClient = _this;\n          return {\n            create: function create(nextPolicy, options) {\n              if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {\n                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(credentials, (serviceClient.baseUri || \"\") + \"/.default\");\n              }\n\n              return bearerTokenPolicyFactory.create(nextPolicy, options);\n            }\n          };\n        };\n\n        authPolicyFactory = wrappedPolicyFactory();\n      } else if (credentials && typeof credentials.signRequest === \"function\") {\n        logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n        authPolicyFactory = signingPolicy(credentials);\n      } else if (credentials !== undefined && credentials !== null) {\n        throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n      }\n\n      logger.info(\"ServiceClient: using default request policies\");\n      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n\n      if (options.requestPolicyFactories) {\n        // options.requestPolicyFactories can also be a function that manipulates\n        // the default requestPolicyFactories array\n        var newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);\n\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n\n\n  ServiceClient.prototype.sendRequest = function (options) {\n    if (options === null || options === undefined || typeof options !== \"object\") {\n      throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n    }\n\n    var httpRequest;\n\n    try {\n      if (isWebResourceLike(options)) {\n        options.validateRequestProperties();\n        httpRequest = options;\n      } else {\n        httpRequest = new WebResource();\n        httpRequest = httpRequest.prepare(options);\n      }\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    var httpPipeline = this._httpClient;\n\n    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n      for (var i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n        httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);\n      }\n    }\n\n    return httpPipeline.sendRequest(httpRequest);\n  };\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @param {OperationArguments} operationArguments The arguments that the HTTP request's templated values will be populated from.\n   * @param {OperationSpec} operationSpec The OperationSpec to use to populate the httpRequest.\n   * @param {ServiceCallback} callback The callback to call when the response is received.\n   */\n\n\n  ServiceClient.prototype.sendOperationRequest = function (operationArguments, operationSpec, callback) {\n    return __awaiter(this, void 0, void 0, function () {\n      var httpRequest, result, baseUri, requestUrl, _i, _a, urlParameter, urlParameterValue, _b, _c, queryParameter, queryParameterValue, index, item, index, contentType, _d, _e, headerParameter, headerValue, headerCollectionPrefix, _f, _g, key, options, customHeaderName, rawResponse, sendRequestError, error_1, error_2, cb;\n\n      return __generator(this, function (_h) {\n        switch (_h.label) {\n          case 0:\n            if (typeof operationArguments.options === \"function\") {\n              callback = operationArguments.options;\n              operationArguments.options = undefined;\n            }\n\n            httpRequest = new WebResource();\n            _h.label = 1;\n\n          case 1:\n            _h.trys.push([1, 6,, 7]);\n\n            baseUri = operationSpec.baseUrl || this.baseUri;\n\n            if (!baseUri) {\n              throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\");\n            }\n\n            httpRequest.method = operationSpec.httpMethod;\n            httpRequest.operationSpec = operationSpec;\n            requestUrl = URLBuilder.parse(baseUri);\n\n            if (operationSpec.path) {\n              requestUrl.appendPath(operationSpec.path);\n            }\n\n            if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n              for (_i = 0, _a = operationSpec.urlParameters; _i < _a.length; _i++) {\n                urlParameter = _a[_i];\n                urlParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, urlParameter, operationSpec.serializer);\n                urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter(urlParameter));\n\n                if (!urlParameter.skipEncoding) {\n                  urlParameterValue = encodeURIComponent(urlParameterValue);\n                }\n\n                requestUrl.replaceAll(\"{\" + (urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)) + \"}\", urlParameterValue);\n              }\n            }\n\n            if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {\n              for (_b = 0, _c = operationSpec.queryParameters; _b < _c.length; _b++) {\n                queryParameter = _c[_b];\n                queryParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, queryParameter, operationSpec.serializer);\n\n                if (queryParameterValue !== undefined && queryParameterValue !== null) {\n                  queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));\n\n                  if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null) {\n                    if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {\n                      if (queryParameterValue.length === 0) {\n                        queryParameterValue = \"\";\n                      } else {\n                        for (index in queryParameterValue) {\n                          item = queryParameterValue[index];\n                          queryParameterValue[index] = item === undefined || item === null ? \"\" : item.toString();\n                        }\n                      }\n                    } else if (queryParameter.collectionFormat === QueryCollectionFormat.Ssv || queryParameter.collectionFormat === QueryCollectionFormat.Tsv) {\n                      queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n                    }\n                  }\n\n                  if (!queryParameter.skipEncoding) {\n                    if (Array.isArray(queryParameterValue)) {\n                      for (index in queryParameterValue) {\n                        if (queryParameterValue[index] !== undefined && queryParameterValue[index] !== null) {\n                          queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);\n                        }\n                      }\n                    } else {\n                      queryParameterValue = encodeURIComponent(queryParameterValue);\n                    }\n                  }\n\n                  if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null && queryParameter.collectionFormat !== QueryCollectionFormat.Multi && queryParameter.collectionFormat !== QueryCollectionFormat.Ssv && queryParameter.collectionFormat !== QueryCollectionFormat.Tsv) {\n                    queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n                  }\n\n                  requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n                }\n              }\n            }\n\n            httpRequest.url = requestUrl.toString();\n            contentType = operationSpec.contentType || this.requestContentType;\n\n            if (contentType) {\n              httpRequest.headers.set(\"Content-Type\", contentType);\n            }\n\n            if (operationSpec.headerParameters) {\n              for (_d = 0, _e = operationSpec.headerParameters; _d < _e.length; _d++) {\n                headerParameter = _e[_d];\n                headerValue = getOperationArgumentValueFromParameter(this, operationArguments, headerParameter, operationSpec.serializer);\n\n                if (headerValue !== undefined && headerValue !== null) {\n                  headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));\n                  headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;\n\n                  if (headerCollectionPrefix) {\n                    for (_f = 0, _g = Object.keys(headerValue); _f < _g.length; _f++) {\n                      key = _g[_f];\n                      httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n                    }\n                  } else {\n                    httpRequest.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n                  }\n                }\n              }\n            }\n\n            options = operationArguments.options;\n\n            if (options) {\n              if (options.customHeaders) {\n                for (customHeaderName in options.customHeaders) {\n                  httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n                }\n              }\n\n              if (options.abortSignal) {\n                httpRequest.abortSignal = options.abortSignal;\n              }\n\n              if (options.timeout) {\n                httpRequest.timeout = options.timeout;\n              }\n\n              if (options.onUploadProgress) {\n                httpRequest.onUploadProgress = options.onUploadProgress;\n              }\n\n              if (options.onDownloadProgress) {\n                httpRequest.onDownloadProgress = options.onDownloadProgress;\n              }\n\n              if (options.spanOptions) {\n                httpRequest.spanOptions = options.spanOptions;\n              }\n\n              if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {\n                httpRequest.shouldDeserialize = options.shouldDeserialize;\n              }\n            }\n\n            httpRequest.withCredentials = this._withCredentials;\n            serializeRequestBody(this, httpRequest, operationArguments, operationSpec);\n\n            if (httpRequest.streamResponseBody === undefined || httpRequest.streamResponseBody === null) {\n              httpRequest.streamResponseBody = isStreamOperation(operationSpec);\n            }\n\n            rawResponse = void 0;\n            sendRequestError = void 0;\n            _h.label = 2;\n\n          case 2:\n            _h.trys.push([2, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , this.sendRequest(httpRequest)];\n\n          case 3:\n            rawResponse = _h.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            error_1 = _h.sent();\n            sendRequestError = error_1;\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            if (sendRequestError) {\n              if (sendRequestError.response) {\n                sendRequestError.details = flattenResponse(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] || operationSpec.responses[\"default\"]);\n              }\n\n              result = Promise.reject(sendRequestError);\n            } else {\n              result = Promise.resolve(flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]));\n            }\n\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            error_2 = _h.sent();\n            result = Promise.reject(error_2);\n            return [3\n            /*break*/\n            , 7];\n\n          case 7:\n            cb = callback;\n\n            if (cb) {\n              result // tslint:disable-next-line:no-null-keyword\n              .then(function (res) {\n                return cb(null, res._response.parsedBody, res._response.request, res._response);\n              }).catch(function (err) {\n                return cb(err);\n              });\n            }\n\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n\n  return ServiceClient;\n}();\n\nexport { ServiceClient };\nexport function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {\n  var _a;\n\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);\n    var bodyMapper = operationSpec.requestBody.mapper;\n    var required = bodyMapper.required,\n        xmlName = bodyMapper.xmlName,\n        xmlElementName = bodyMapper.xmlElementName,\n        serializedName = bodyMapper.serializedName;\n    var typeName = bodyMapper.type.name;\n\n    try {\n      if (httpRequest.body !== undefined && httpRequest.body !== null || required) {\n        var requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n        httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString);\n        var isStream = typeName === MapperType.Stream;\n\n        if (operationSpec.isXML) {\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(utils.prepareXMLRootList(httpRequest.body, xmlElementName || xmlName || serializedName), {\n              rootName: xmlName || serializedName\n            });\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(httpRequest.body, {\n              rootName: xmlName || serializedName\n            });\n          }\n        } else if (typeName === MapperType.String && (((_a = operationSpec.contentType) === null || _a === void 0 ? void 0 : _a.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(\"Error \\\"\" + error.message + \"\\\" occurred in serializing the payload - \" + JSON.stringify(serializedName, undefined, \"  \") + \".\");\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n\n    for (var _i = 0, _b = operationSpec.formDataParameters; _i < _b.length; _i++) {\n      var formDataParameter = _b[_i];\n      var formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);\n\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        var formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter));\n      }\n    }\n  }\n}\n\nfunction getValueOrFunctionResult(value, defaultValueCreator) {\n  var result;\n\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n\n  return result;\n}\n\nfunction createDefaultRequestPolicyFactories(authPolicyFactory, options) {\n  var factories = [];\n\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n\n  if (authPolicyFactory) {\n    factories.push(authPolicyFactory);\n  }\n\n  var userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName);\n  var userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, getDefaultUserAgentValue);\n\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({\n      key: userAgentHeaderName,\n      value: userAgentHeaderValue\n    }));\n  }\n\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n\n  if (isNode) {\n    factories.push(proxyPolicy(options.proxySettings));\n  }\n\n  factories.push(logPolicy({\n    logger: logger.info\n  }));\n  return factories;\n}\n\nexport function createPipelineFromOptions(pipelineOptions, authPolicyFactory) {\n  var requestPolicyFactories = [];\n  var userAgentValue = undefined;\n\n  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n    var userAgentInfo = [];\n    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix); // Add the default user agent value if it isn't already specified\n    // by the userAgentPrefix option.\n\n    var defaultUserAgentInfo = getDefaultUserAgentValue();\n\n    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n      userAgentInfo.push(defaultUserAgentInfo);\n    }\n\n    userAgentValue = userAgentInfo.join(\" \");\n  }\n\n  var keepAliveOptions = __assign(__assign({}, DefaultKeepAliveOptions), pipelineOptions.keepAliveOptions);\n\n  var retryOptions = __assign(__assign({}, DefaultRetryOptions), pipelineOptions.retryOptions);\n\n  var redirectOptions = __assign(__assign({}, DefaultRedirectOptions), pipelineOptions.redirectOptions);\n\n  if (isNode) {\n    requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));\n  }\n\n  var deserializationOptions = __assign(__assign({}, DefaultDeserializationOptions), pipelineOptions.deserializationOptions);\n\n  var loggingOptions = __assign({}, pipelineOptions.loggingOptions);\n\n  requestPolicyFactories.push(tracingPolicy({\n    userAgent: userAgentValue\n  }), keepAlivePolicy(keepAliveOptions), userAgentPolicy({\n    value: userAgentValue\n  }), generateClientRequestIdPolicy(), deserializationPolicy(deserializationOptions.expectedContentTypes), throttlingRetryPolicy(), systemErrorRetryPolicy(), exponentialRetryPolicy(retryOptions.maxRetries, retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs));\n\n  if (redirectOptions.handleRedirects) {\n    requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));\n  }\n\n  if (authPolicyFactory) {\n    requestPolicyFactories.push(authPolicyFactory);\n  }\n\n  requestPolicyFactories.push(logPolicy(loggingOptions));\n\n  if (isNode && pipelineOptions.decompressResponse === false) {\n    requestPolicyFactories.push(disableResponseDecompressionPolicy());\n  }\n\n  return {\n    httpClient: pipelineOptions.httpClient,\n    requestPolicyFactories: requestPolicyFactories\n  };\n}\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\n\nexport function getPropertyParent(parent, propertyPath) {\n  if (parent && propertyPath) {\n    var propertyPathLength = propertyPath.length;\n\n    for (var i = 0; i < propertyPathLength - 1; ++i) {\n      var propertyName = propertyPath[i];\n\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n\n      parent = parent[propertyName];\n    }\n  }\n\n  return parent;\n}\n\nfunction getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer) {\n  return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer);\n}\n\nexport function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer) {\n  var value;\n\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        var propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);\n\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n\n        var useDefaultValue = false;\n\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue = parameterMapper.required || parameterPath[0] === \"options\" && parameterPath.length === 2;\n        }\n\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      } // Serialize just for validation purposes.\n\n\n      var parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);\n      serializer.serialize(parameterMapper, value, parameterPathString);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n\n    for (var propertyName in parameterPath) {\n      var propertyMapper = parameterMapper.type.modelProperties[propertyName];\n      var propertyPath = parameterPath[propertyName];\n      var propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer); // Serialize just for validation purposes.\n\n      var propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString);\n\n      if (propertyValue !== undefined && propertyValue !== null) {\n        if (!value) {\n          value = {};\n        }\n\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction getPropertyFromParameterPath(parent, parameterPath) {\n  var result = {\n    propertyFound: false\n  };\n  var i = 0;\n\n  for (; i < parameterPath.length; ++i) {\n    var parameterPathPart = parameterPath[i]; // Make sure to check inherited properties too, so don't use hasOwnProperty().\n\n    if (parent !== undefined && parent !== null && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n\n  return result;\n}\n\nexport function flattenResponse(_response, responseSpec) {\n  var parsedHeaders = _response.parsedHeaders;\n  var bodyMapper = responseSpec && responseSpec.bodyMapper;\n\n  var addOperationResponse = function addOperationResponse(obj) {\n    return Object.defineProperty(obj, \"_response\", {\n      value: _response\n    });\n  };\n\n  if (bodyMapper) {\n    var typeName = bodyMapper.type.name;\n\n    if (typeName === \"Stream\") {\n      return addOperationResponse(__assign(__assign({}, parsedHeaders), {\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody\n      }));\n    }\n\n    var modelProperties_1 = typeName === \"Composite\" && bodyMapper.type.modelProperties || {};\n    var isPageableResponse = Object.keys(modelProperties_1).some(function (k) {\n      return modelProperties_1[k].serializedName === \"\";\n    });\n\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      var arrayResponse = __spreadArrays(_response.parsedBody || []);\n\n      for (var _i = 0, _a = Object.keys(modelProperties_1); _i < _a.length; _i++) {\n        var key = _a[_i];\n\n        if (modelProperties_1[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n\n      if (parsedHeaders) {\n        for (var _b = 0, _c = Object.keys(parsedHeaders); _b < _c.length; _b++) {\n          var key = _c[_b];\n          arrayResponse[key] = parsedHeaders[key];\n        }\n      }\n\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse(__assign(__assign({}, parsedHeaders), _response.parsedBody));\n    }\n  }\n\n  if (bodyMapper || _response.request.method === \"HEAD\" || utils.isPrimitiveType(_response.parsedBody)) {\n    // primitive body types and HEAD booleans\n    return addOperationResponse(__assign(__assign({}, parsedHeaders), {\n      body: _response.parsedBody\n    }));\n  }\n\n  return addOperationResponse(__assign(__assign({}, parsedHeaders), _response.parsedBody));\n}","map":{"version":3,"sources":["../../src/serviceClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { DefaultHttpClient } from \"./defaultHttpClient\";\nimport { HttpClient } from \"./httpClient\";\nimport { HttpOperationResponse, RestResponse } from \"./httpOperationResponse\";\nimport { HttpPipelineLogger } from \"./httpPipelineLogger\";\nimport { logPolicy, LogPolicyOptions } from \"./policies/logPolicy\";\nimport { OperationArguments } from \"./operationArguments\";\nimport {\n  getPathStringFromParameter,\n  getPathStringFromParameterPath,\n  OperationParameter,\n  ParameterPath\n} from \"./operationParameter\";\nimport { isStreamOperation, OperationSpec } from \"./operationSpec\";\nimport {\n  deserializationPolicy,\n  DeserializationContentTypes,\n  DefaultDeserializationOptions\n} from \"./policies/deserializationPolicy\";\nimport { exponentialRetryPolicy, DefaultRetryOptions } from \"./policies/exponentialRetryPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport {\n  userAgentPolicy,\n  getDefaultUserAgentHeaderName,\n  getDefaultUserAgentValue\n} from \"./policies/userAgentPolicy\";\nimport { redirectPolicy, DefaultRedirectOptions } from \"./policies/redirectPolicy\";\nimport {\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./policies/requestPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { CompositeMapper, DictionaryMapper, Mapper, MapperType, Serializer } from \"./serializer\";\nimport { URLBuilder } from \"./url\";\nimport * as utils from \"./util/utils\";\nimport { stringifyXML } from \"./util/xml\";\nimport {\n  RequestOptionsBase,\n  RequestPrepareOptions,\n  WebResource,\n  WebResourceLike,\n  isWebResourceLike\n} from \"./webResource\";\nimport { OperationResponse } from \"./operationResponse\";\nimport { ServiceCallback, isNode } from \"./util/utils\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { ServiceClientCredentials } from \"./credentials/serviceClientCredentials\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { logger } from \"./log\";\nimport { InternalPipelineOptions } from \"./pipelineOptions\";\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from \"./policies/keepAlivePolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\nimport { disableResponseDecompressionPolicy } from \"./policies/disableResponseDecompressionPolicy\";\n\n/**\n * Options to configure a proxy for outgoing requests (Node.js only).\n */\nexport interface ProxySettings {\n  /**\n   * The proxy's host address.\n   */\n  host: string;\n\n  /**\n   * The proxy host's port.\n   */\n  port: number;\n\n  /**\n   * The user name to authenticate with the proxy, if required.\n   */\n  username?: string;\n\n  /**\n   * The password to authenticate with the proxy, if required.\n   */\n  password?: string;\n}\n\nexport type ProxyOptions = ProxySettings; // Alias ProxySettings as ProxyOptions for future use.\n\n/**\n * Options to be provided while creating the client.\n */\nexport interface ServiceClientOptions {\n  /**\n   * An array of factories which get called to create the RequestPolicy pipeline used to send a HTTP\n   * request on the wire, or a function that takes in the defaultRequestPolicyFactories and returns\n   * the requestPolicyFactories that will be used.\n   */\n  requestPolicyFactories?:\n    | RequestPolicyFactory[]\n    | ((defaultRequestPolicyFactories: RequestPolicyFactory[]) => void | RequestPolicyFactory[]);\n  /**\n   * The HttpClient that will be used to send HTTP requests.\n   */\n  httpClient?: HttpClient;\n  /**\n   * The HttpPipelineLogger that can be used to debug RequestPolicies within the HTTP pipeline.\n   */\n  httpPipelineLogger?: HttpPipelineLogger;\n  /**\n   * If set to true, turn off the default retry policy.\n   */\n  noRetryPolicy?: boolean;\n  /**\n   * Gets or sets the retry timeout in seconds for AutomaticRPRegistration. Default value is 30.\n   */\n  rpRegistrationRetryTimeout?: number;\n  /**\n   * Whether or not to generate a client request ID header for each HTTP request.\n   */\n  generateClientRequestIdHeader?: boolean;\n  /**\n   * Whether to include credentials in CORS requests in the browser.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials for more information.\n   */\n  withCredentials?: boolean;\n  /**\n   * If specified, a GenerateRequestIdPolicy will be added to the HTTP pipeline that will add a\n   * header to all outgoing requests with this header name and a random UUID as the request ID.\n   */\n  clientRequestIdHeaderName?: string;\n  /**\n   * The content-types that will be associated with JSON or XML serialization.\n   */\n  deserializationContentTypes?: DeserializationContentTypes;\n  /**\n   * The header name to use for the telemetry header while sending the request. If this is not\n   * specified, then \"User-Agent\" will be used when running on Node.js and \"x-ms-useragent\" will\n   * be used when running in a browser.\n   */\n  userAgentHeaderName?: string | ((defaultUserAgentHeaderName: string) => string);\n  /**\n   * The string to be set to the telemetry header while sending the request, or a function that\n   * takes in the default user-agent string and returns the user-agent string that will be used.\n   */\n  userAgent?: string | ((defaultUserAgent: string) => string);\n  /**\n   * Proxy settings which will be used for every HTTP request (Node.js only).\n   */\n  proxySettings?: ProxySettings;\n}\n\n/**\n * @class\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   */\n  protected baseUri?: string;\n\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  protected requestContentType?: string;\n\n  /**\n   * The HTTP client that will be used to send requests.\n   */\n  private readonly _httpClient: HttpClient;\n  private readonly _requestPolicyOptions: RequestPolicyOptions;\n\n  private readonly _requestPolicyFactories: RequestPolicyFactory[];\n  private readonly _withCredentials: boolean;\n\n  /**\n   * The ServiceClient constructor\n   * @constructor\n   * @param credentials The credentials used for authentication with the service.\n   * @param options The service client options that govern the behavior of the client.\n   */\n  constructor(\n    credentials?: TokenCredential | ServiceClientCredentials,\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options?: ServiceClientOptions\n  ) {\n    if (!options) {\n      options = {};\n    }\n\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || new DefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n\n    let requestPolicyFactories: RequestPolicyFactory[];\n    if (Array.isArray(options.requestPolicyFactories)) {\n      logger.info(\"ServiceClient: using custom request policies\");\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      let authPolicyFactory: RequestPolicyFactory | undefined = undefined;\n      if (isTokenCredential(credentials)) {\n        logger.info(\n          \"ServiceClient: creating bearer token authentication policy from provided credentials\"\n        );\n        // Create a wrapped RequestPolicyFactory here so that we can provide the\n        // correct scope to the BearerTokenAuthenticationPolicy at the first time\n        // one is requested.  This is needed because generated ServiceClient\n        // implementations do not set baseUri until after ServiceClient's constructor\n        // is finished, leaving baseUri empty at the time when it is needed to\n        // build the correct scope name.\n        const wrappedPolicyFactory: () => RequestPolicyFactory = () => {\n          let bearerTokenPolicyFactory: RequestPolicyFactory | undefined = undefined;\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const serviceClient = this;\n          return {\n            create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): RequestPolicy {\n              if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {\n                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(\n                  credentials,\n                  `${serviceClient.baseUri || \"\"}/.default`\n                );\n              }\n\n              return bearerTokenPolicyFactory.create(nextPolicy, options);\n            }\n          };\n        };\n\n        authPolicyFactory = wrappedPolicyFactory();\n      } else if (credentials && typeof credentials.signRequest === \"function\") {\n        logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n        authPolicyFactory = signingPolicy(credentials);\n      } else if (credentials !== undefined && credentials !== null) {\n        throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n      }\n\n      logger.info(\"ServiceClient: using default request policies\");\n      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n      if (options.requestPolicyFactories) {\n        // options.requestPolicyFactories can also be a function that manipulates\n        // the default requestPolicyFactories array\n        const newRequestPolicyFactories:\n          | void\n          | RequestPolicyFactory[] = options.requestPolicyFactories(requestPolicyFactories);\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n\n  /**\n   * Send the provided httpRequest.\n   */\n  sendRequest(options: RequestPrepareOptions | WebResourceLike): Promise<HttpOperationResponse> {\n    if (options === null || options === undefined || typeof options !== \"object\") {\n      throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n    }\n\n    let httpRequest: WebResourceLike;\n    try {\n      if (isWebResourceLike(options)) {\n        options.validateRequestProperties();\n        httpRequest = options;\n      } else {\n        httpRequest = new WebResource();\n        httpRequest = httpRequest.prepare(options);\n      }\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    let httpPipeline: RequestPolicy = this._httpClient;\n    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n      for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n        httpPipeline = this._requestPolicyFactories[i].create(\n          httpPipeline,\n          this._requestPolicyOptions\n        );\n      }\n    }\n    return httpPipeline.sendRequest(httpRequest);\n  }\n\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @param {OperationArguments} operationArguments The arguments that the HTTP request's templated values will be populated from.\n   * @param {OperationSpec} operationSpec The OperationSpec to use to populate the httpRequest.\n   * @param {ServiceCallback} callback The callback to call when the response is received.\n   */\n  async sendOperationRequest(\n    operationArguments: OperationArguments,\n    operationSpec: OperationSpec,\n    callback?: ServiceCallback<any>\n  ): Promise<RestResponse> {\n    if (typeof operationArguments.options === \"function\") {\n      callback = operationArguments.options;\n      operationArguments.options = undefined;\n    }\n\n    const httpRequest: WebResourceLike = new WebResource();\n\n    let result: Promise<RestResponse>;\n    try {\n      const baseUri: string | undefined = operationSpec.baseUrl || this.baseUri;\n      if (!baseUri) {\n        throw new Error(\n          \"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\"\n        );\n      }\n\n      httpRequest.method = operationSpec.httpMethod;\n      httpRequest.operationSpec = operationSpec;\n\n      const requestUrl: URLBuilder = URLBuilder.parse(baseUri);\n      if (operationSpec.path) {\n        requestUrl.appendPath(operationSpec.path);\n      }\n      if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n        for (const urlParameter of operationSpec.urlParameters) {\n          let urlParameterValue: string = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            urlParameter,\n            operationSpec.serializer\n          );\n          urlParameterValue = operationSpec.serializer.serialize(\n            urlParameter.mapper,\n            urlParameterValue,\n            getPathStringFromParameter(urlParameter)\n          );\n          if (!urlParameter.skipEncoding) {\n            urlParameterValue = encodeURIComponent(urlParameterValue);\n          }\n          requestUrl.replaceAll(\n            `{${urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)}}`,\n            urlParameterValue\n          );\n        }\n      }\n      if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {\n        for (const queryParameter of operationSpec.queryParameters) {\n          let queryParameterValue: any = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            queryParameter,\n            operationSpec.serializer\n          );\n          if (queryParameterValue !== undefined && queryParameterValue !== null) {\n            queryParameterValue = operationSpec.serializer.serialize(\n              queryParameter.mapper,\n              queryParameterValue,\n              getPathStringFromParameter(queryParameter)\n            );\n            if (\n              queryParameter.collectionFormat !== undefined &&\n              queryParameter.collectionFormat !== null\n            ) {\n              if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {\n                if (queryParameterValue.length === 0) {\n                  queryParameterValue = \"\";\n                } else {\n                  for (const index in queryParameterValue) {\n                    const item = queryParameterValue[index];\n                    queryParameterValue[index] =\n                      item === undefined || item === null ? \"\" : item.toString();\n                  }\n                }\n              } else if (\n                queryParameter.collectionFormat === QueryCollectionFormat.Ssv ||\n                queryParameter.collectionFormat === QueryCollectionFormat.Tsv\n              ) {\n                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n              }\n            }\n            if (!queryParameter.skipEncoding) {\n              if (Array.isArray(queryParameterValue)) {\n                for (const index in queryParameterValue) {\n                  if (\n                    queryParameterValue[index] !== undefined &&\n                    queryParameterValue[index] !== null\n                  ) {\n                    queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);\n                  }\n                }\n              } else {\n                queryParameterValue = encodeURIComponent(queryParameterValue);\n              }\n            }\n            if (\n              queryParameter.collectionFormat !== undefined &&\n              queryParameter.collectionFormat !== null &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Multi &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Ssv &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Tsv\n            ) {\n              queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n            }\n            requestUrl.setQueryParameter(\n              queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter),\n              queryParameterValue\n            );\n          }\n        }\n      }\n      httpRequest.url = requestUrl.toString();\n\n      const contentType = operationSpec.contentType || this.requestContentType;\n      if (contentType) {\n        httpRequest.headers.set(\"Content-Type\", contentType);\n      }\n\n      if (operationSpec.headerParameters) {\n        for (const headerParameter of operationSpec.headerParameters) {\n          let headerValue: any = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            headerParameter,\n            operationSpec.serializer\n          );\n          if (headerValue !== undefined && headerValue !== null) {\n            headerValue = operationSpec.serializer.serialize(\n              headerParameter.mapper,\n              headerValue,\n              getPathStringFromParameter(headerParameter)\n            );\n            const headerCollectionPrefix = (headerParameter.mapper as DictionaryMapper)\n              .headerCollectionPrefix;\n            if (headerCollectionPrefix) {\n              for (const key of Object.keys(headerValue)) {\n                httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n              }\n            } else {\n              httpRequest.headers.set(\n                headerParameter.mapper.serializedName ||\n                  getPathStringFromParameter(headerParameter),\n                headerValue\n              );\n            }\n          }\n        }\n      }\n\n      const options: RequestOptionsBase | undefined = operationArguments.options;\n      if (options) {\n        if (options.customHeaders) {\n          for (const customHeaderName in options.customHeaders) {\n            httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n          }\n        }\n\n        if (options.abortSignal) {\n          httpRequest.abortSignal = options.abortSignal;\n        }\n\n        if (options.timeout) {\n          httpRequest.timeout = options.timeout;\n        }\n\n        if (options.onUploadProgress) {\n          httpRequest.onUploadProgress = options.onUploadProgress;\n        }\n\n        if (options.onDownloadProgress) {\n          httpRequest.onDownloadProgress = options.onDownloadProgress;\n        }\n\n        if (options.spanOptions) {\n          httpRequest.spanOptions = options.spanOptions;\n        }\n\n        if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {\n          httpRequest.shouldDeserialize = options.shouldDeserialize;\n        }\n      }\n\n      httpRequest.withCredentials = this._withCredentials;\n\n      serializeRequestBody(this, httpRequest, operationArguments, operationSpec);\n\n      if (httpRequest.streamResponseBody === undefined || httpRequest.streamResponseBody === null) {\n        httpRequest.streamResponseBody = isStreamOperation(operationSpec);\n      }\n\n      let rawResponse: HttpOperationResponse;\n      let sendRequestError;\n      try {\n        rawResponse = await this.sendRequest(httpRequest);\n      } catch (error) {\n        sendRequestError = error;\n      }\n      if (sendRequestError) {\n        if (sendRequestError.response) {\n          sendRequestError.details = flattenResponse(\n            sendRequestError.response,\n            operationSpec.responses[sendRequestError.statusCode] ||\n              operationSpec.responses[\"default\"]\n          );\n        }\n        result = Promise.reject(sendRequestError);\n      } else {\n        result = Promise.resolve(\n          flattenResponse(rawResponse!, operationSpec.responses[rawResponse!.status])\n        );\n      }\n    } catch (error) {\n      result = Promise.reject(error);\n    }\n\n    const cb = callback;\n    if (cb) {\n      result\n        // tslint:disable-next-line:no-null-keyword\n        .then((res) => cb(null, res._response.parsedBody, res._response.request, res._response))\n        .catch((err) => cb(err));\n    }\n\n    return result;\n  }\n}\n\nexport function serializeRequestBody(\n  serviceClient: ServiceClient,\n  httpRequest: WebResourceLike,\n  operationArguments: OperationArguments,\n  operationSpec: OperationSpec\n): void {\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(\n      serviceClient,\n      operationArguments,\n      operationSpec.requestBody,\n      operationSpec.serializer\n    );\n\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const { required, xmlName, xmlElementName, serializedName } = bodyMapper;\n    const typeName = bodyMapper.type.name;\n\n    try {\n      if ((httpRequest.body !== undefined && httpRequest.body !== null) || required) {\n        const requestBodyParameterPathString: string = getPathStringFromParameter(\n          operationSpec.requestBody\n        );\n        httpRequest.body = operationSpec.serializer.serialize(\n          bodyMapper,\n          httpRequest.body,\n          requestBodyParameterPathString\n        );\n\n        const isStream = typeName === MapperType.Stream;\n\n        if (operationSpec.isXML) {\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(\n              utils.prepareXMLRootList(\n                httpRequest.body,\n                xmlElementName || xmlName || serializedName!\n              ),\n              { rootName: xmlName || serializedName }\n            );\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(httpRequest.body, {\n              rootName: xmlName || serializedName\n            });\n          }\n        } else if (\n          typeName === MapperType.String &&\n          (operationSpec.contentType?.match(\"text/plain\") || operationSpec.mediaType === \"text\")\n        ) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(\n        `Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(\n          serializedName,\n          undefined,\n          \"  \"\n        )}.`\n      );\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue: any = getOperationArgumentValueFromParameter(\n        serviceClient,\n        operationArguments,\n        formDataParameter,\n        operationSpec.serializer\n      );\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName: string =\n          formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(\n          formDataParameter.mapper,\n          formDataParameterValue,\n          getPathStringFromParameter(formDataParameter)\n        );\n      }\n    }\n  }\n}\n\nfunction getValueOrFunctionResult(\n  value: undefined | string | ((defaultValue: string) => string),\n  defaultValueCreator: () => string\n): string {\n  let result: string;\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n  return result;\n}\n\nfunction createDefaultRequestPolicyFactories(\n  authPolicyFactory: RequestPolicyFactory | undefined,\n  options: ServiceClientOptions\n): RequestPolicyFactory[] {\n  const factories: RequestPolicyFactory[] = [];\n\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n\n  if (authPolicyFactory) {\n    factories.push(authPolicyFactory);\n  }\n\n  const userAgentHeaderName: string = getValueOrFunctionResult(\n    options.userAgentHeaderName,\n    getDefaultUserAgentHeaderName\n  );\n  const userAgentHeaderValue: string = getValueOrFunctionResult(\n    options.userAgent,\n    getDefaultUserAgentValue\n  );\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({ key: userAgentHeaderName, value: userAgentHeaderValue }));\n  }\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n\n  if (isNode) {\n    factories.push(proxyPolicy(options.proxySettings));\n  }\n\n  factories.push(logPolicy({ logger: logger.info }));\n\n  return factories;\n}\n\nexport function createPipelineFromOptions(\n  pipelineOptions: InternalPipelineOptions,\n  authPolicyFactory?: RequestPolicyFactory\n): ServiceClientOptions {\n  const requestPolicyFactories: RequestPolicyFactory[] = [];\n\n  let userAgentValue = undefined;\n  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n    const userAgentInfo: string[] = [];\n    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);\n\n    // Add the default user agent value if it isn't already specified\n    // by the userAgentPrefix option.\n    const defaultUserAgentInfo = getDefaultUserAgentValue();\n    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n      userAgentInfo.push(defaultUserAgentInfo);\n    }\n\n    userAgentValue = userAgentInfo.join(\" \");\n  }\n\n  const keepAliveOptions = {\n    ...DefaultKeepAliveOptions,\n    ...pipelineOptions.keepAliveOptions\n  };\n\n  const retryOptions = {\n    ...DefaultRetryOptions,\n    ...pipelineOptions.retryOptions\n  };\n\n  const redirectOptions = {\n    ...DefaultRedirectOptions,\n    ...pipelineOptions.redirectOptions\n  };\n\n  if (isNode) {\n    requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));\n  }\n\n  const deserializationOptions = {\n    ...DefaultDeserializationOptions,\n    ...pipelineOptions.deserializationOptions\n  };\n\n  const loggingOptions: LogPolicyOptions = {\n    ...pipelineOptions.loggingOptions\n  };\n\n  requestPolicyFactories.push(\n    tracingPolicy({ userAgent: userAgentValue }),\n    keepAlivePolicy(keepAliveOptions),\n    userAgentPolicy({ value: userAgentValue }),\n    generateClientRequestIdPolicy(),\n    deserializationPolicy(deserializationOptions.expectedContentTypes),\n    throttlingRetryPolicy(),\n    systemErrorRetryPolicy(),\n    exponentialRetryPolicy(\n      retryOptions.maxRetries,\n      retryOptions.retryDelayInMs,\n      retryOptions.maxRetryDelayInMs\n    )\n  );\n\n  if (redirectOptions.handleRedirects) {\n    requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));\n  }\n\n  if (authPolicyFactory) {\n    requestPolicyFactories.push(authPolicyFactory);\n  }\n\n  requestPolicyFactories.push(logPolicy(loggingOptions));\n\n  if (isNode && pipelineOptions.decompressResponse === false) {\n    requestPolicyFactories.push(disableResponseDecompressionPolicy());\n  }\n\n  return {\n    httpClient: pipelineOptions.httpClient,\n    requestPolicyFactories\n  };\n}\n\nexport type PropertyParent = { [propertyName: string]: any };\n\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\nexport function getPropertyParent(parent: PropertyParent, propertyPath: string[]): PropertyParent {\n  if (parent && propertyPath) {\n    const propertyPathLength: number = propertyPath.length;\n    for (let i = 0; i < propertyPathLength - 1; ++i) {\n      const propertyName: string = propertyPath[i];\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n      parent = parent[propertyName];\n    }\n  }\n  return parent;\n}\n\nfunction getOperationArgumentValueFromParameter(\n  serviceClient: ServiceClient,\n  operationArguments: OperationArguments,\n  parameter: OperationParameter,\n  serializer: Serializer\n): any {\n  return getOperationArgumentValueFromParameterPath(\n    serviceClient,\n    operationArguments,\n    parameter.parameterPath,\n    parameter.mapper,\n    serializer\n  );\n}\n\nexport function getOperationArgumentValueFromParameterPath(\n  serviceClient: ServiceClient,\n  operationArguments: OperationArguments,\n  parameterPath: ParameterPath,\n  parameterMapper: Mapper,\n  serializer: Serializer\n): any {\n  let value: any;\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        let propertySearchResult: PropertySearchResult = getPropertyFromParameterPath(\n          operationArguments,\n          parameterPath\n        );\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n\n        let useDefaultValue = false;\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue =\n            parameterMapper.required ||\n            (parameterPath[0] === \"options\" && parameterPath.length === 2);\n        }\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      }\n\n      // Serialize just for validation purposes.\n      const parameterPathString: string = getPathStringFromParameterPath(\n        parameterPath,\n        parameterMapper\n      );\n      serializer.serialize(parameterMapper, value, parameterPathString);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n\n    for (const propertyName in parameterPath) {\n      const propertyMapper: Mapper = (parameterMapper as CompositeMapper).type.modelProperties![\n        propertyName\n      ];\n      const propertyPath: ParameterPath = parameterPath[propertyName];\n      const propertyValue: any = getOperationArgumentValueFromParameterPath(\n        serviceClient,\n        operationArguments,\n        propertyPath,\n        propertyMapper,\n        serializer\n      );\n      // Serialize just for validation purposes.\n      const propertyPathString: string = getPathStringFromParameterPath(\n        propertyPath,\n        propertyMapper\n      );\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString);\n      if (propertyValue !== undefined && propertyValue !== null) {\n        if (!value) {\n          value = {};\n        }\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n  return value;\n}\n\ninterface PropertySearchResult {\n  propertyValue?: any;\n  propertyFound: boolean;\n}\n\nfunction getPropertyFromParameterPath(\n  parent: { [parameterName: string]: any },\n  parameterPath: string[]\n): PropertySearchResult {\n  const result: PropertySearchResult = { propertyFound: false };\n  let i = 0;\n  for (; i < parameterPath.length; ++i) {\n    const parameterPathPart: string = parameterPath[i];\n    // Make sure to check inherited properties too, so don't use hasOwnProperty().\n    if (parent !== undefined && parent !== null && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n  return result;\n}\n\nexport function flattenResponse(\n  _response: HttpOperationResponse,\n  responseSpec: OperationResponse | undefined\n): RestResponse {\n  const parsedHeaders = _response.parsedHeaders;\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n\n  const addOperationResponse = (obj: {}): {\n    _response: HttpOperationResponse;\n  } => {\n    return Object.defineProperty(obj, \"_response\", {\n      value: _response\n    });\n  };\n\n  if (bodyMapper) {\n    const typeName = bodyMapper.type.name;\n    if (typeName === \"Stream\") {\n      return addOperationResponse({\n        ...parsedHeaders,\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody\n      });\n    }\n\n    const modelProperties =\n      (typeName === \"Composite\" && (bodyMapper as CompositeMapper).type.modelProperties) || {};\n    const isPageableResponse = Object.keys(modelProperties).some(\n      (k) => modelProperties[k].serializedName === \"\"\n    );\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      const arrayResponse = [...(_response.parsedBody || [])] as RestResponse & any[];\n\n      for (const key of Object.keys(modelProperties)) {\n        if (modelProperties[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n\n      if (parsedHeaders) {\n        for (const key of Object.keys(parsedHeaders)) {\n          arrayResponse[key] = parsedHeaders[key];\n        }\n      }\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse({\n        ...parsedHeaders,\n        ..._response.parsedBody\n      });\n    }\n  }\n\n  if (\n    bodyMapper ||\n    _response.request.method === \"HEAD\" ||\n    utils.isPrimitiveType(_response.parsedBody)\n  ) {\n    // primitive body types and HEAD booleans\n    return addOperationResponse({\n      ...parsedHeaders,\n      body: _response.parsedBody\n    });\n  }\n\n  return addOperationResponse({\n    ...parsedHeaders,\n    ..._response.parsedBody\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}