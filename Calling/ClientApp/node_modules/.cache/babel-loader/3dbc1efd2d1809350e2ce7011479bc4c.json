{"ast":null,"code":"import { CallClient } from '@azure/communication-calling';\nimport { AzureCommunicationUserCredential } from '@azure/communication-common';\nimport { utils } from '../Utils/Utils';\nimport { callAdded, callRemoved, setCallState, setParticipants, setCallAgent } from './actions/calls';\nimport { setMic, setShareScreen, resetControls } from './actions/controls';\nimport { setAudioDeviceInfo, setAudioDeviceList, setCameraPermission, setMicrophonePermission, setVideoDeviceInfo, setVideoDeviceList, setDeviceManager } from './actions/devices';\nimport { addScreenShareStream, resetStreams, removeScreenShareStream } from './actions/streams';\nexport const setMicrophone = mic => {\n  return async (dispatch, getState) => {\n    const state = getState();\n\n    if (state === undefined || state.calls.call === undefined) {\n      console.error('state or state.controls.mic is null');\n      return;\n    }\n\n    try {\n      if (!state.controls.mic) {\n        await state.calls.call.unmute();\n      } else {\n        await state.calls.call.mute();\n      }\n\n      dispatch(setMic(mic));\n    } catch (e) {\n      console.error(e);\n    }\n  };\n};\nexport const setShareUnshareScreen = shareScreen => {\n  return async (dispatch, getState) => {\n    const state = getState();\n\n    if (state === undefined || state.calls.call === undefined) {\n      console.error('state or state.controls.shareScreen is null');\n      return;\n    }\n\n    try {\n      if (!state.controls.shareScreen) {\n        await state.calls.call.startScreenSharing();\n      } else {\n        await state.calls.call.stopScreenSharing();\n      }\n\n      dispatch(setShareScreen(shareScreen));\n    } catch (e) {\n      console.error(e);\n    }\n  };\n};\nexport const updateDevices = () => {\n  return async (dispatch, getState) => {\n    let state = getState();\n    let deviceManager = state.devices.deviceManager;\n\n    if (deviceManager == null) {\n      console.error('no device manager available');\n      return;\n    }\n\n    const cameraList = await deviceManager.getCameraList();\n    dispatch(setVideoDeviceList(cameraList));\n    const microphoneList = await deviceManager.getMicrophoneList();\n    dispatch(setAudioDeviceList(microphoneList));\n  };\n};\nexport const initCallClient = (userId, unsupportedStateHandler, endCallHandler) => {\n  return async (dispatch, getState) => {\n    try {\n      const tokenResponse = await utils.getTokenForUser(userId);\n      const options = {};\n      const userToken = tokenResponse.value.token;\n      var callClient; // check if chrome/ios\n\n      if (utils.isOnIphoneAndNotSafari()) {\n        unsupportedStateHandler();\n        return;\n      }\n\n      try {\n        callClient = new CallClient(options);\n      } catch (e) {\n        unsupportedStateHandler();\n        return;\n      }\n\n      if (!callClient) {\n        return;\n      }\n\n      const tokenCredential = new AzureCommunicationUserCredential(userToken);\n      let callAgent = await callClient.createCallAgent(tokenCredential);\n\n      if (callAgent === undefined) {\n        return;\n      }\n\n      callAgent.updateDisplayName(userId);\n      let deviceManager = await callClient.getDeviceManager();\n      dispatch(setDeviceManager(deviceManager));\n      dispatch(setCallAgent(callAgent));\n      subscribeToDeviceManager(deviceManager, dispatch, getState);\n      callAgent.on('callsUpdated', e => {\n        e.added.forEach(addedCall => {\n          const state = getState();\n\n          if (state.calls.call && addedCall.isIncoming) {\n            addedCall.reject();\n            return;\n          }\n\n          dispatch(callAdded(addedCall));\n          addedCall.on('callStateChanged', () => {\n            dispatch(setCallState(addedCall.state));\n          });\n          addedCall.on('isScreenSharingOnChanged', () => {\n            dispatch(setShareScreen(addedCall.isScreenSharingOn));\n          });\n          addedCall.on('remoteParticipantsUpdated', ev => {\n            ev.added.forEach(addedRemoteParticipant => {\n              console.log('participantAdded', addedRemoteParticipant);\n              subscribeToParticipant(addedRemoteParticipant, addedCall, dispatch, getState);\n              dispatch(setParticipants([...addedCall.remoteParticipants.values()]));\n            }); // we don't use the actual value we are just going to reset the remoteParticipants based on the call\n\n            if (ev.removed.length > 0) {\n              console.log('participantRemoved');\n              dispatch(setParticipants([...addedCall.remoteParticipants.values()]));\n            }\n          });\n          const rp = [...addedCall.remoteParticipants.values()];\n          rp.forEach(v => subscribeToParticipant(v, addedCall, dispatch, getState));\n          dispatch(setParticipants(rp));\n          dispatch(setCallState(addedCall.state));\n        });\n        e.removed.forEach(removedCall => {\n          console.log('callRemoved', removedCall);\n          const state = getState();\n\n          if (state.calls.call && state.calls.call === removedCall) {\n            dispatch(callRemoved(removedCall, state.calls.group));\n            dispatch(resetControls());\n            dispatch(resetStreams());\n          }\n        });\n      });\n    } catch (e) {\n      console.error(e);\n    }\n  };\n}; // what does the forEveryone parameter really mean?\n\nexport const endCall = async (call, options) => {\n  call.hangUp(options).catch(e => console.error(e));\n};\nexport const joinGroup = async (callAgent, context, callOptions) => {\n  try {\n    await callAgent.join(context, callOptions);\n  } catch (e) {\n    console.log('Failed to join a call', e);\n    return;\n  }\n};\nexport const addParticipant = async (call, user) => {\n  call.addParticipant(user);\n};\nexport const removeParticipant = async (call, user) => {\n  call.removeParticipant(user).catch(e => console.error(e));\n};\n\nconst subscribeToParticipant = (participant, call, dispatch, getState) => {\n  const userId = utils.getId(participant.identifier);\n  participant.on('participantStateChanged', () => {\n    console.log('participant stateChanged', userId, participant.state);\n    dispatch(setParticipants([...call.remoteParticipants.values()]));\n  });\n  participant.on('isSpeakingChanged', () => {\n    dispatch(setParticipants([...call.remoteParticipants.values()]));\n  });\n  participant.on('videoStreamsUpdated', e => {\n    e.added.forEach(addedStream => {\n      if (addedStream.type === 'Video') {\n        return;\n      }\n\n      addedStream.on('availabilityChanged', () => {\n        if (addedStream.isAvailable) {\n          dispatch(addScreenShareStream(addedStream, participant));\n        } else {\n          dispatch(removeScreenShareStream(addedStream, participant));\n        }\n      });\n\n      if (addedStream.isAvailable) {\n        dispatch(addScreenShareStream(addedStream, participant));\n      }\n    });\n  });\n};\n\nconst updateAudioDevices = async (deviceManager, dispatch, getState) => {\n  const microphoneList = await deviceManager.getMicrophoneList();\n  dispatch(setAudioDeviceList(microphoneList));\n  const state = getState();\n\n  if (state.devices.audioDeviceInfo === undefined && microphoneList.length > 0) {\n    dispatch(setAudioDeviceInfo(microphoneList[0]));\n    deviceManager.setMicrophone(microphoneList[0]);\n  } else if (state.devices.audioDeviceInfo && !utils.isSelectedAudioDeviceInList(state.devices.audioDeviceInfo, microphoneList)) {\n    deviceManager.setMicrophone(state.devices.audioDeviceInfo);\n  }\n};\n\nconst updateVideoDevices = async (deviceManager, dispatch, getState) => {\n  const cameraList = deviceManager.getCameraList();\n  dispatch(setVideoDeviceList(cameraList));\n  const state = getState();\n\n  if (state.devices.videoDeviceInfo === undefined) {\n    dispatch(setVideoDeviceInfo(cameraList[0]));\n  } else if (state.devices.videoDeviceInfo && !utils.isSelectedVideoDeviceInList(state.devices.videoDeviceInfo, cameraList)) {\n    dispatch(setVideoDeviceInfo(state.devices.videoDeviceInfo));\n  }\n};\n\nconst subscribeToDeviceManager = async (deviceManager, dispatch, getState) => {\n  // listen for any new events\n  deviceManager.on('permissionStateChanged', async () => {\n    const cameraPermissionState = await deviceManager.getPermissionState('Camera');\n    dispatch(setCameraPermission(cameraPermissionState));\n    const microphonePermissionState = await deviceManager.getPermissionState('Microphone');\n    dispatch(setMicrophonePermission(microphonePermissionState));\n  });\n  deviceManager.on('videoDevicesUpdated', async () => {\n    updateVideoDevices(deviceManager, dispatch, getState);\n  });\n  deviceManager.on('audioDevicesUpdated', async () => {\n    updateAudioDevices(deviceManager, dispatch, getState);\n  });\n  deviceManager.askDevicePermission(true, true).then(e => {\n    if (e.audio !== undefined) {\n      if (e.audio) {\n        dispatch(setMicrophonePermission('Granted'));\n        updateAudioDevices(deviceManager, dispatch, getState);\n      } else {\n        dispatch(setMicrophonePermission('Denied'));\n      }\n    }\n\n    if (e.video !== undefined) {\n      if (e.video) {\n        dispatch(setCameraPermission('Granted'));\n        updateVideoDevices(deviceManager, dispatch, getState);\n      } else {\n        dispatch(setCameraPermission('Denied'));\n      }\n    }\n  });\n};","map":{"version":3,"sources":["C:/Users/t-tamina/source/repos/Communication/samples/Group Calling Hero Sample/Web/Calling/ClientApp/src/core/sideEffects.ts"],"names":["CallClient","AzureCommunicationUserCredential","utils","callAdded","callRemoved","setCallState","setParticipants","setCallAgent","setMic","setShareScreen","resetControls","setAudioDeviceInfo","setAudioDeviceList","setCameraPermission","setMicrophonePermission","setVideoDeviceInfo","setVideoDeviceList","setDeviceManager","addScreenShareStream","resetStreams","removeScreenShareStream","setMicrophone","mic","dispatch","getState","state","undefined","calls","call","console","error","controls","unmute","mute","e","setShareUnshareScreen","shareScreen","startScreenSharing","stopScreenSharing","updateDevices","deviceManager","devices","cameraList","getCameraList","microphoneList","getMicrophoneList","initCallClient","userId","unsupportedStateHandler","endCallHandler","tokenResponse","getTokenForUser","options","userToken","value","token","callClient","isOnIphoneAndNotSafari","tokenCredential","callAgent","createCallAgent","updateDisplayName","getDeviceManager","subscribeToDeviceManager","on","added","forEach","addedCall","isIncoming","reject","isScreenSharingOn","ev","addedRemoteParticipant","log","subscribeToParticipant","remoteParticipants","values","removed","length","rp","v","removedCall","group","endCall","hangUp","catch","joinGroup","context","callOptions","join","addParticipant","user","removeParticipant","participant","getId","identifier","addedStream","type","isAvailable","updateAudioDevices","audioDeviceInfo","isSelectedAudioDeviceInList","updateVideoDevices","videoDeviceInfo","isSelectedVideoDeviceInList","cameraPermissionState","getPermissionState","microphonePermissionState","askDevicePermission","then","audio","video"],"mappings":"AAAA,SAaEA,UAbF,QAeO,8BAfP;AAgBA,SAASC,gCAAT,QAAwF,6BAAxF;AAEA,SAASC,KAAT,QAAsB,gBAAtB;AACA,SAASC,SAAT,EAAoBC,WAApB,EAAiCC,YAAjC,EAA+CC,eAA/C,EAAgEC,YAAhE,QAAoF,iBAApF;AACA,SAASC,MAAT,EAAiBC,cAAjB,EAAiCC,aAAjC,QAAsD,oBAAtD;AACA,SACEC,kBADF,EAEEC,kBAFF,EAGEC,mBAHF,EAIEC,uBAJF,EAKEC,kBALF,EAMEC,kBANF,EAOEC,gBAPF,QAQO,mBARP;AASA,SAASC,oBAAT,EAA+BC,YAA/B,EAA6CC,uBAA7C,QAA4E,mBAA5E;AAGA,OAAO,MAAMC,aAAa,GAAIC,GAAD,IAAkB;AAC7C,SAAO,OAAOC,QAAP,EAA2BC,QAA3B,KAAqD;AAC1D,UAAMC,KAAK,GAAGD,QAAQ,EAAtB;;AAEA,QAAIC,KAAK,KAAKC,SAAV,IAAuBD,KAAK,CAACE,KAAN,CAAYC,IAAZ,KAAqBF,SAAhD,EAA2D;AACzDG,MAAAA,OAAO,CAACC,KAAR,CAAc,qCAAd;AACA;AACD;;AAED,QAAI;AACF,UAAI,CAACL,KAAK,CAACM,QAAN,CAAeT,GAApB,EAAyB;AACvB,cAAMG,KAAK,CAACE,KAAN,CAAYC,IAAZ,CAAiBI,MAAjB,EAAN;AACD,OAFD,MAEO;AACL,cAAMP,KAAK,CAACE,KAAN,CAAYC,IAAZ,CAAiBK,IAAjB,EAAN;AACD;;AAEDV,MAAAA,QAAQ,CAACf,MAAM,CAACc,GAAD,CAAP,CAAR;AACD,KARD,CAQE,OAAOY,CAAP,EAAU;AACVL,MAAAA,OAAO,CAACC,KAAR,CAAcI,CAAd;AACD;AACF,GAnBD;AAoBD,CArBM;AAuBP,OAAO,MAAMC,qBAAqB,GAAIC,WAAD,IAA0B;AAC7D,SAAO,OAAOb,QAAP,EAA2BC,QAA3B,KAAqD;AAC1D,UAAMC,KAAK,GAAGD,QAAQ,EAAtB;;AAEA,QAAIC,KAAK,KAAKC,SAAV,IAAuBD,KAAK,CAACE,KAAN,CAAYC,IAAZ,KAAqBF,SAAhD,EAA2D;AACzDG,MAAAA,OAAO,CAACC,KAAR,CAAc,6CAAd;AACA;AACD;;AAED,QAAI;AACF,UAAI,CAACL,KAAK,CAACM,QAAN,CAAeK,WAApB,EAAiC;AAC/B,cAAMX,KAAK,CAACE,KAAN,CAAYC,IAAZ,CAAiBS,kBAAjB,EAAN;AACD,OAFD,MAEO;AACL,cAAMZ,KAAK,CAACE,KAAN,CAAYC,IAAZ,CAAiBU,iBAAjB,EAAN;AACD;;AAEDf,MAAAA,QAAQ,CAACd,cAAc,CAAC2B,WAAD,CAAf,CAAR;AACD,KARD,CAQE,OAAOF,CAAP,EAAU;AACVL,MAAAA,OAAO,CAACC,KAAR,CAAcI,CAAd;AACD;AACF,GAnBD;AAoBD,CArBM;AAuBP,OAAO,MAAMK,aAAa,GAAG,MAAM;AACjC,SAAO,OAAOhB,QAAP,EAA2BC,QAA3B,KAAqD;AAC1D,QAAIC,KAAK,GAAGD,QAAQ,EAApB;AACA,QAAIgB,aAAa,GAAGf,KAAK,CAACgB,OAAN,CAAcD,aAAlC;;AAEA,QAAIA,aAAa,IAAI,IAArB,EAA2B;AACzBX,MAAAA,OAAO,CAACC,KAAR,CAAc,6BAAd;AACA;AACD;;AAED,UAAMY,UAA6B,GAAG,MAAMF,aAAa,CAACG,aAAd,EAA5C;AAEApB,IAAAA,QAAQ,CAACP,kBAAkB,CAAC0B,UAAD,CAAnB,CAAR;AAEA,UAAME,cAAiC,GAAG,MAAMJ,aAAa,CAACK,iBAAd,EAAhD;AAEAtB,IAAAA,QAAQ,CAACX,kBAAkB,CAACgC,cAAD,CAAnB,CAAR;AACD,GAhBD;AAiBD,CAlBM;AAoBP,OAAO,MAAME,cAAc,GAAG,CAACC,MAAD,EAAiBC,uBAAjB,EAAsDC,cAAtD,KAAqF;AACjH,SAAO,OAAO1B,QAAP,EAA2BC,QAA3B,KAAqD;AAC1D,QAAI;AACF,YAAM0B,aAAa,GAAG,MAAMhD,KAAK,CAACiD,eAAN,CAAsBJ,MAAtB,CAA5B;AAEA,YAAMK,OAA0B,GAAG,EAAnC;AAEA,YAAMC,SAAS,GAAGH,aAAa,CAACI,KAAd,CAAoBC,KAAtC;AAEA,UAAIC,UAAJ,CAPE,CASF;;AACA,UAAItD,KAAK,CAACuD,sBAAN,EAAJ,EAAoC;AAClCT,QAAAA,uBAAuB;AACvB;AACD;;AAED,UAAI;AACFQ,QAAAA,UAAU,GAAG,IAAIxD,UAAJ,CAAeoD,OAAf,CAAb;AACD,OAFD,CAEE,OAAOlB,CAAP,EAAU;AACVc,QAAAA,uBAAuB;AACvB;AACD;;AAED,UAAI,CAACQ,UAAL,EAAiB;AACf;AACD;;AAED,YAAME,eAAe,GAAG,IAAIzD,gCAAJ,CAAqCoD,SAArC,CAAxB;AACA,UAAIM,SAAoB,GAAG,MAAMH,UAAU,CAACI,eAAX,CAA2BF,eAA3B,CAAjC;;AAEA,UAAIC,SAAS,KAAKjC,SAAlB,EAA6B;AAC3B;AACD;;AAEDiC,MAAAA,SAAS,CAACE,iBAAV,CAA4Bd,MAA5B;AAEA,UAAIP,aAA4B,GAAG,MAAMgB,UAAU,CAACM,gBAAX,EAAzC;AAEAvC,MAAAA,QAAQ,CAACN,gBAAgB,CAACuB,aAAD,CAAjB,CAAR;AACAjB,MAAAA,QAAQ,CAAChB,YAAY,CAACoD,SAAD,CAAb,CAAR;AAEAI,MAAAA,wBAAwB,CAACvB,aAAD,EAAgBjB,QAAhB,EAA0BC,QAA1B,CAAxB;AAEAmC,MAAAA,SAAS,CAACK,EAAV,CAAa,cAAb,EAA8B9B,CAAD,IAAiD;AAC5EA,QAAAA,CAAC,CAAC+B,KAAF,CAAQC,OAAR,CAAiBC,SAAD,IAAe;AAC7B,gBAAM1C,KAAK,GAAGD,QAAQ,EAAtB;;AACA,cAAIC,KAAK,CAACE,KAAN,CAAYC,IAAZ,IAAoBuC,SAAS,CAACC,UAAlC,EAA8C;AAC5CD,YAAAA,SAAS,CAACE,MAAV;AACA;AACD;;AAED9C,UAAAA,QAAQ,CAACpB,SAAS,CAACgE,SAAD,CAAV,CAAR;AAEAA,UAAAA,SAAS,CAACH,EAAV,CAAa,kBAAb,EAAiC,MAAY;AAC3CzC,YAAAA,QAAQ,CAAClB,YAAY,CAAC8D,SAAS,CAAC1C,KAAX,CAAb,CAAR;AACD,WAFD;AAIA0C,UAAAA,SAAS,CAACH,EAAV,CAAa,0BAAb,EAAyC,MAAY;AACnDzC,YAAAA,QAAQ,CAACd,cAAc,CAAC0D,SAAS,CAACG,iBAAX,CAAf,CAAR;AACD,WAFD;AAIAH,UAAAA,SAAS,CAACH,EAAV,CAAa,2BAAb,EAA2CO,EAAD,IAAc;AACtDA,YAAAA,EAAE,CAACN,KAAH,CAASC,OAAT,CAAkBM,sBAAD,IAA4B;AAC3C3C,cAAAA,OAAO,CAAC4C,GAAR,CAAY,kBAAZ,EAAgCD,sBAAhC;AACAE,cAAAA,sBAAsB,CAACF,sBAAD,EAAyBL,SAAzB,EAAoC5C,QAApC,EAA8CC,QAA9C,CAAtB;AACAD,cAAAA,QAAQ,CAACjB,eAAe,CAAC,CAAC,GAAG6D,SAAS,CAACQ,kBAAV,CAA6BC,MAA7B,EAAJ,CAAD,CAAhB,CAAR;AACD,aAJD,EADsD,CAOtD;;AACA,gBAAIL,EAAE,CAACM,OAAH,CAAWC,MAAX,GAAoB,CAAxB,EAA2B;AACzBjD,cAAAA,OAAO,CAAC4C,GAAR,CAAY,oBAAZ;AACAlD,cAAAA,QAAQ,CAACjB,eAAe,CAAC,CAAC,GAAG6D,SAAS,CAACQ,kBAAV,CAA6BC,MAA7B,EAAJ,CAAD,CAAhB,CAAR;AACD;AACF,WAZD;AAcA,gBAAMG,EAAE,GAAG,CAAC,GAAGZ,SAAS,CAACQ,kBAAV,CAA6BC,MAA7B,EAAJ,CAAX;AACAG,UAAAA,EAAE,CAACb,OAAH,CAAYc,CAAD,IAAON,sBAAsB,CAACM,CAAD,EAAIb,SAAJ,EAAe5C,QAAf,EAAyBC,QAAzB,CAAxC;AACAD,UAAAA,QAAQ,CAACjB,eAAe,CAACyE,EAAD,CAAhB,CAAR;AACAxD,UAAAA,QAAQ,CAAClB,YAAY,CAAC8D,SAAS,CAAC1C,KAAX,CAAb,CAAR;AACD,SAnCD;AAoCAS,QAAAA,CAAC,CAAC2C,OAAF,CAAUX,OAAV,CAAmBe,WAAD,IAAiB;AACjCpD,UAAAA,OAAO,CAAC4C,GAAR,CAAY,aAAZ,EAA2BQ,WAA3B;AACA,gBAAMxD,KAAK,GAAGD,QAAQ,EAAtB;;AACA,cAAIC,KAAK,CAACE,KAAN,CAAYC,IAAZ,IAAoBH,KAAK,CAACE,KAAN,CAAYC,IAAZ,KAAqBqD,WAA7C,EAA0D;AACxD1D,YAAAA,QAAQ,CAACnB,WAAW,CAAC6E,WAAD,EAAcxD,KAAK,CAACE,KAAN,CAAYuD,KAA1B,CAAZ,CAAR;AACA3D,YAAAA,QAAQ,CAACb,aAAa,EAAd,CAAR;AACAa,YAAAA,QAAQ,CAACJ,YAAY,EAAb,CAAR;AACD;AACF,SARD;AASD,OA9CD;AA+CD,KAzFD,CAyFE,OAAOe,CAAP,EAAU;AACVL,MAAAA,OAAO,CAACC,KAAR,CAAcI,CAAd;AACD;AACF,GA7FD;AA8FD,CA/FM,C,CAiGP;;AACA,OAAO,MAAMiD,OAAO,GAAG,OAAOvD,IAAP,EAAmBwB,OAAnB,KAAkD;AACvExB,EAAAA,IAAI,CAACwD,MAAL,CAAYhC,OAAZ,EAAqBiC,KAArB,CAA4BnD,CAAD,IAA2BL,OAAO,CAACC,KAAR,CAAcI,CAAd,CAAtD;AACD,CAFM;AAIP,OAAO,MAAMoD,SAAS,GAAG,OAAO3B,SAAP,EAA6B4B,OAA7B,EAAwDC,WAAxD,KAAyF;AAChH,MAAI;AACF,UAAM7B,SAAS,CAAC8B,IAAV,CAAeF,OAAf,EAAwBC,WAAxB,CAAN;AACD,GAFD,CAEE,OAAOtD,CAAP,EAAU;AACVL,IAAAA,OAAO,CAAC4C,GAAR,CAAY,uBAAZ,EAAqCvC,CAArC;AACA;AACD;AACF,CAPM;AASP,OAAO,MAAMwD,cAAc,GAAG,OAAO9D,IAAP,EAAmB+D,IAAnB,KAAoE;AAChG/D,EAAAA,IAAI,CAAC8D,cAAL,CAAoBC,IAApB;AACD,CAFM;AAIP,OAAO,MAAMC,iBAAiB,GAAG,OAAOhE,IAAP,EAAmB+D,IAAnB,KAAoE;AACnG/D,EAAAA,IAAI,CAACgE,iBAAL,CAAuBD,IAAvB,EAA6BN,KAA7B,CAAoCnD,CAAD,IAA2BL,OAAO,CAACC,KAAR,CAAcI,CAAd,CAA9D;AACD,CAFM;;AAIP,MAAMwC,sBAAsB,GAAG,CAC7BmB,WAD6B,EAE7BjE,IAF6B,EAG7BL,QAH6B,EAI7BC,QAJ6B,KAK1B;AACH,QAAMuB,MAAM,GAAG7C,KAAK,CAAC4F,KAAN,CAAYD,WAAW,CAACE,UAAxB,CAAf;AACAF,EAAAA,WAAW,CAAC7B,EAAZ,CAAe,yBAAf,EAA0C,MAAM;AAC9CnC,IAAAA,OAAO,CAAC4C,GAAR,CAAY,0BAAZ,EAAwC1B,MAAxC,EAAgD8C,WAAW,CAACpE,KAA5D;AACAF,IAAAA,QAAQ,CAACjB,eAAe,CAAC,CAAC,GAAGsB,IAAI,CAAC+C,kBAAL,CAAwBC,MAAxB,EAAJ,CAAD,CAAhB,CAAR;AACD,GAHD;AAKAiB,EAAAA,WAAW,CAAC7B,EAAZ,CAAe,mBAAf,EAAoC,MAAM;AACxCzC,IAAAA,QAAQ,CAACjB,eAAe,CAAC,CAAC,GAAGsB,IAAI,CAAC+C,kBAAL,CAAwBC,MAAxB,EAAJ,CAAD,CAAhB,CAAR;AACD,GAFD;AAIAiB,EAAAA,WAAW,CAAC7B,EAAZ,CAAe,qBAAf,EAAuC9B,CAAD,IAAa;AACjDA,IAAAA,CAAC,CAAC+B,KAAF,CAAQC,OAAR,CAAiB8B,WAAD,IAAiB;AAC/B,UAAIA,WAAW,CAACC,IAAZ,KAAqB,OAAzB,EAAkC;AAChC;AACD;;AACDD,MAAAA,WAAW,CAAChC,EAAZ,CAAe,qBAAf,EAAsC,MAAM;AAC1C,YAAIgC,WAAW,CAACE,WAAhB,EAA6B;AAC3B3E,UAAAA,QAAQ,CAACL,oBAAoB,CAAC8E,WAAD,EAAcH,WAAd,CAArB,CAAR;AACD,SAFD,MAEO;AACLtE,UAAAA,QAAQ,CAACH,uBAAuB,CAAC4E,WAAD,EAAcH,WAAd,CAAxB,CAAR;AACD;AACF,OAND;;AAQA,UAAIG,WAAW,CAACE,WAAhB,EAA6B;AAC3B3E,QAAAA,QAAQ,CAACL,oBAAoB,CAAC8E,WAAD,EAAcH,WAAd,CAArB,CAAR;AACD;AACF,KAfD;AAgBD,GAjBD;AAkBD,CAlCD;;AAoCA,MAAMM,kBAAkB,GAAG,OAAO3D,aAAP,EAAqCjB,QAArC,EAAyDC,QAAzD,KAAmF;AAC5G,QAAMoB,cAAiC,GAAG,MAAMJ,aAAa,CAACK,iBAAd,EAAhD;AACAtB,EAAAA,QAAQ,CAACX,kBAAkB,CAACgC,cAAD,CAAnB,CAAR;AAEA,QAAMnB,KAAK,GAAGD,QAAQ,EAAtB;;AACA,MAAIC,KAAK,CAACgB,OAAN,CAAc2D,eAAd,KAAkC1E,SAAlC,IAA+CkB,cAAc,CAACkC,MAAf,GAAwB,CAA3E,EAA8E;AAC5EvD,IAAAA,QAAQ,CAACZ,kBAAkB,CAACiC,cAAc,CAAC,CAAD,CAAf,CAAnB,CAAR;AACAJ,IAAAA,aAAa,CAACnB,aAAd,CAA4BuB,cAAc,CAAC,CAAD,CAA1C;AACD,GAHD,MAGO,IACLnB,KAAK,CAACgB,OAAN,CAAc2D,eAAd,IACA,CAAClG,KAAK,CAACmG,2BAAN,CAAkC5E,KAAK,CAACgB,OAAN,CAAc2D,eAAhD,EAAiExD,cAAjE,CAFI,EAGL;AACAJ,IAAAA,aAAa,CAACnB,aAAd,CAA4BI,KAAK,CAACgB,OAAN,CAAc2D,eAA1C;AACD;AACF,CAdD;;AAgBA,MAAME,kBAAkB,GAAG,OAAO9D,aAAP,EAAqCjB,QAArC,EAAyDC,QAAzD,KAAmF;AAC5G,QAAMkB,UAA6B,GAAGF,aAAa,CAACG,aAAd,EAAtC;AACApB,EAAAA,QAAQ,CAACP,kBAAkB,CAAC0B,UAAD,CAAnB,CAAR;AAEA,QAAMjB,KAAK,GAAGD,QAAQ,EAAtB;;AACA,MAAIC,KAAK,CAACgB,OAAN,CAAc8D,eAAd,KAAkC7E,SAAtC,EAAiD;AAC/CH,IAAAA,QAAQ,CAACR,kBAAkB,CAAC2B,UAAU,CAAC,CAAD,CAAX,CAAnB,CAAR;AACD,GAFD,MAEO,IACLjB,KAAK,CAACgB,OAAN,CAAc8D,eAAd,IACA,CAACrG,KAAK,CAACsG,2BAAN,CAAkC/E,KAAK,CAACgB,OAAN,CAAc8D,eAAhD,EAAiE7D,UAAjE,CAFI,EAGL;AACAnB,IAAAA,QAAQ,CAACR,kBAAkB,CAACU,KAAK,CAACgB,OAAN,CAAc8D,eAAf,CAAnB,CAAR;AACD;AACF,CAbD;;AAeA,MAAMxC,wBAAwB,GAAG,OAAOvB,aAAP,EAAqCjB,QAArC,EAAyDC,QAAzD,KAAmF;AAClH;AACAgB,EAAAA,aAAa,CAACwB,EAAd,CAAiB,wBAAjB,EAA2C,YAAY;AACrD,UAAMyC,qBAAsC,GAAG,MAAMjE,aAAa,CAACkE,kBAAd,CAAiC,QAAjC,CAArD;AACAnF,IAAAA,QAAQ,CAACV,mBAAmB,CAAC4F,qBAAD,CAApB,CAAR;AAEA,UAAME,yBAA0C,GAAG,MAAMnE,aAAa,CAACkE,kBAAd,CAAiC,YAAjC,CAAzD;AACAnF,IAAAA,QAAQ,CAACT,uBAAuB,CAAC6F,yBAAD,CAAxB,CAAR;AACD,GAND;AAQAnE,EAAAA,aAAa,CAACwB,EAAd,CAAiB,qBAAjB,EAAwC,YAAY;AAClDsC,IAAAA,kBAAkB,CAAC9D,aAAD,EAAgBjB,QAAhB,EAA0BC,QAA1B,CAAlB;AACD,GAFD;AAIAgB,EAAAA,aAAa,CAACwB,EAAd,CAAiB,qBAAjB,EAAwC,YAAY;AAClDmC,IAAAA,kBAAkB,CAAC3D,aAAD,EAAgBjB,QAAhB,EAA0BC,QAA1B,CAAlB;AACD,GAFD;AAIAgB,EAAAA,aAAa,CAACoE,mBAAd,CAAkC,IAAlC,EAAwC,IAAxC,EAA8CC,IAA9C,CAAoD3E,CAAD,IAAqB;AACtE,QAAIA,CAAC,CAAC4E,KAAF,KAAYpF,SAAhB,EAA2B;AACzB,UAAIQ,CAAC,CAAC4E,KAAN,EAAa;AACXvF,QAAAA,QAAQ,CAACT,uBAAuB,CAAC,SAAD,CAAxB,CAAR;AAEAqF,QAAAA,kBAAkB,CAAC3D,aAAD,EAAgBjB,QAAhB,EAA0BC,QAA1B,CAAlB;AACD,OAJD,MAIO;AACLD,QAAAA,QAAQ,CAACT,uBAAuB,CAAC,QAAD,CAAxB,CAAR;AACD;AACF;;AAED,QAAIoB,CAAC,CAAC6E,KAAF,KAAYrF,SAAhB,EAA2B;AACzB,UAAIQ,CAAC,CAAC6E,KAAN,EAAa;AACXxF,QAAAA,QAAQ,CAACV,mBAAmB,CAAC,SAAD,CAApB,CAAR;AACAyF,QAAAA,kBAAkB,CAAC9D,aAAD,EAAgBjB,QAAhB,EAA0BC,QAA1B,CAAlB;AACD,OAHD,MAGO;AACLD,QAAAA,QAAQ,CAACV,mBAAmB,CAAC,QAAD,CAApB,CAAR;AACD;AACF;AACF,GAnBD;AAoBD,CAtCD","sourcesContent":["import {\r\n  AudioDeviceInfo,\r\n  Call,\r\n  CallClientOptions,\r\n  CommunicationError,\r\n  GroupCallContext,\r\n  JoinCallOptions,\r\n  DeviceManager,\r\n  DeviceAccess,\r\n  PermissionState,\r\n  RemoteParticipant,\r\n  VideoDeviceInfo,\r\n  CallAgent,\r\n  CallClient,\r\n  HangupCallOptions\r\n} from '@azure/communication-calling';\r\nimport { AzureCommunicationUserCredential, CommunicationUser, CallingApplication } from '@azure/communication-common';\r\nimport { Dispatch } from 'redux';\r\nimport { utils } from '../Utils/Utils';\r\nimport { callAdded, callRemoved, setCallState, setParticipants, setCallAgent } from './actions/calls';\r\nimport { setMic, setShareScreen, resetControls } from './actions/controls';\r\nimport {\r\n  setAudioDeviceInfo,\r\n  setAudioDeviceList,\r\n  setCameraPermission,\r\n  setMicrophonePermission,\r\n  setVideoDeviceInfo,\r\n  setVideoDeviceList,\r\n  setDeviceManager\r\n} from './actions/devices';\r\nimport { addScreenShareStream, resetStreams, removeScreenShareStream } from './actions/streams';\r\nimport { State } from './reducers';\r\n\r\nexport const setMicrophone = (mic: boolean) => {\r\n  return async (dispatch: Dispatch, getState: () => State) => {\r\n    const state = getState();\r\n\r\n    if (state === undefined || state.calls.call === undefined) {\r\n      console.error('state or state.controls.mic is null');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      if (!state.controls.mic) {\r\n        await state.calls.call.unmute();\r\n      } else {\r\n        await state.calls.call.mute();\r\n      }\r\n\r\n      dispatch(setMic(mic));\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n  };\r\n};\r\n\r\nexport const setShareUnshareScreen = (shareScreen: boolean) => {\r\n  return async (dispatch: Dispatch, getState: () => State) => {\r\n    const state = getState();\r\n\r\n    if (state === undefined || state.calls.call === undefined) {\r\n      console.error('state or state.controls.shareScreen is null');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      if (!state.controls.shareScreen) {\r\n        await state.calls.call.startScreenSharing();\r\n      } else {\r\n        await state.calls.call.stopScreenSharing();\r\n      }\r\n\r\n      dispatch(setShareScreen(shareScreen));\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n  };\r\n};\r\n\r\nexport const updateDevices = () => {\r\n  return async (dispatch: Dispatch, getState: () => State) => {\r\n    let state = getState();\r\n    let deviceManager = state.devices.deviceManager;\r\n\r\n    if (deviceManager == null) {\r\n      console.error('no device manager available');\r\n      return;\r\n    }\r\n\r\n    const cameraList: VideoDeviceInfo[] = await deviceManager.getCameraList();\r\n\r\n    dispatch(setVideoDeviceList(cameraList));\r\n\r\n    const microphoneList: AudioDeviceInfo[] = await deviceManager.getMicrophoneList();\r\n\r\n    dispatch(setAudioDeviceList(microphoneList));\r\n  };\r\n};\r\n\r\nexport const initCallClient = (userId: string, unsupportedStateHandler: () => void, endCallHandler: () => void) => {\r\n  return async (dispatch: Dispatch, getState: () => State) => {\r\n    try {\r\n      const tokenResponse = await utils.getTokenForUser(userId);\r\n\r\n      const options: CallClientOptions = {};\r\n\r\n      const userToken = tokenResponse.value.token;\r\n\r\n      var callClient;\r\n\r\n      // check if chrome/ios\r\n      if (utils.isOnIphoneAndNotSafari()) {\r\n        unsupportedStateHandler();\r\n        return;\r\n      }\r\n\r\n      try {\r\n        callClient = new CallClient(options);\r\n      } catch (e) {\r\n        unsupportedStateHandler();\r\n        return;\r\n      }\r\n\r\n      if (!callClient) {\r\n        return;\r\n      }\r\n\r\n      const tokenCredential = new AzureCommunicationUserCredential(userToken);\r\n      let callAgent: CallAgent = await callClient.createCallAgent(tokenCredential);\r\n\r\n      if (callAgent === undefined) {\r\n        return;\r\n      }\r\n\r\n      callAgent.updateDisplayName(userId);\r\n\r\n      let deviceManager: DeviceManager = await callClient.getDeviceManager();\r\n\r\n      dispatch(setDeviceManager(deviceManager));\r\n      dispatch(setCallAgent(callAgent));\r\n\r\n      subscribeToDeviceManager(deviceManager, dispatch, getState);\r\n\r\n      callAgent.on('callsUpdated', (e: { added: Call[]; removed: Call[] }): void => {\r\n        e.added.forEach((addedCall) => {\r\n          const state = getState();\r\n          if (state.calls.call && addedCall.isIncoming) {\r\n            addedCall.reject();\r\n            return;\r\n          }\r\n\r\n          dispatch(callAdded(addedCall));\r\n\r\n          addedCall.on('callStateChanged', (): void => {\r\n            dispatch(setCallState(addedCall.state));\r\n          });\r\n\r\n          addedCall.on('isScreenSharingOnChanged', (): void => {\r\n            dispatch(setShareScreen(addedCall.isScreenSharingOn));\r\n          });\r\n\r\n          addedCall.on('remoteParticipantsUpdated', (ev): void => {\r\n            ev.added.forEach((addedRemoteParticipant) => {\r\n              console.log('participantAdded', addedRemoteParticipant);\r\n              subscribeToParticipant(addedRemoteParticipant, addedCall, dispatch, getState);\r\n              dispatch(setParticipants([...addedCall.remoteParticipants.values()]));\r\n            });\r\n\r\n            // we don't use the actual value we are just going to reset the remoteParticipants based on the call\r\n            if (ev.removed.length > 0) {\r\n              console.log('participantRemoved');\r\n              dispatch(setParticipants([...addedCall.remoteParticipants.values()]));\r\n            }\r\n          });\r\n\r\n          const rp = [...addedCall.remoteParticipants.values()];\r\n          rp.forEach((v) => subscribeToParticipant(v, addedCall, dispatch, getState));\r\n          dispatch(setParticipants(rp));\r\n          dispatch(setCallState(addedCall.state));\r\n        });\r\n        e.removed.forEach((removedCall) => {\r\n          console.log('callRemoved', removedCall);\r\n          const state = getState();\r\n          if (state.calls.call && state.calls.call === removedCall) {\r\n            dispatch(callRemoved(removedCall, state.calls.group));\r\n            dispatch(resetControls());\r\n            dispatch(resetStreams());\r\n          }\r\n        });\r\n      });\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n  };\r\n};\r\n\r\n// what does the forEveryone parameter really mean?\r\nexport const endCall = async (call: Call, options: HangupCallOptions) => {\r\n  call.hangUp(options).catch((e: CommunicationError) => console.error(e));\r\n};\r\n\r\nexport const joinGroup = async (callAgent: CallAgent, context: GroupCallContext, callOptions: JoinCallOptions) => {\r\n  try {\r\n    await callAgent.join(context, callOptions);\r\n  } catch (e) {\r\n    console.log('Failed to join a call', e);\r\n    return;\r\n  }\r\n};\r\n\r\nexport const addParticipant = async (call: Call, user: CommunicationUser | CallingApplication) => {\r\n  call.addParticipant(user);\r\n};\r\n\r\nexport const removeParticipant = async (call: Call, user: CommunicationUser | CallingApplication) => {\r\n  call.removeParticipant(user).catch((e: CommunicationError) => console.error(e));\r\n};\r\n\r\nconst subscribeToParticipant = (\r\n  participant: RemoteParticipant,\r\n  call: Call,\r\n  dispatch: Dispatch,\r\n  getState: () => State\r\n) => {\r\n  const userId = utils.getId(participant.identifier);\r\n  participant.on('participantStateChanged', () => {\r\n    console.log('participant stateChanged', userId, participant.state);\r\n    dispatch(setParticipants([...call.remoteParticipants.values()]));\r\n  });\r\n\r\n  participant.on('isSpeakingChanged', () => {\r\n    dispatch(setParticipants([...call.remoteParticipants.values()]));\r\n  });\r\n\r\n  participant.on('videoStreamsUpdated', (e): void => {\r\n    e.added.forEach((addedStream) => {\r\n      if (addedStream.type === 'Video') {\r\n        return;\r\n      }\r\n      addedStream.on('availabilityChanged', () => {\r\n        if (addedStream.isAvailable) {\r\n          dispatch(addScreenShareStream(addedStream, participant));\r\n        } else {\r\n          dispatch(removeScreenShareStream(addedStream, participant));\r\n        }\r\n      });\r\n\r\n      if (addedStream.isAvailable) {\r\n        dispatch(addScreenShareStream(addedStream, participant));\r\n      }\r\n    });\r\n  });\r\n};\r\n\r\nconst updateAudioDevices = async (deviceManager: DeviceManager, dispatch: Dispatch, getState: () => State) => {\r\n  const microphoneList: AudioDeviceInfo[] = await deviceManager.getMicrophoneList();\r\n  dispatch(setAudioDeviceList(microphoneList));\r\n\r\n  const state = getState();\r\n  if (state.devices.audioDeviceInfo === undefined && microphoneList.length > 0) {\r\n    dispatch(setAudioDeviceInfo(microphoneList[0]));\r\n    deviceManager.setMicrophone(microphoneList[0]);\r\n  } else if (\r\n    state.devices.audioDeviceInfo &&\r\n    !utils.isSelectedAudioDeviceInList(state.devices.audioDeviceInfo, microphoneList)\r\n  ) {\r\n    deviceManager.setMicrophone(state.devices.audioDeviceInfo);\r\n  }\r\n};\r\n\r\nconst updateVideoDevices = async (deviceManager: DeviceManager, dispatch: Dispatch, getState: () => State) => {\r\n  const cameraList: VideoDeviceInfo[] = deviceManager.getCameraList();\r\n  dispatch(setVideoDeviceList(cameraList));\r\n\r\n  const state = getState();\r\n  if (state.devices.videoDeviceInfo === undefined) {\r\n    dispatch(setVideoDeviceInfo(cameraList[0]));\r\n  } else if (\r\n    state.devices.videoDeviceInfo &&\r\n    !utils.isSelectedVideoDeviceInList(state.devices.videoDeviceInfo, cameraList)\r\n  ) {\r\n    dispatch(setVideoDeviceInfo(state.devices.videoDeviceInfo));\r\n  }\r\n};\r\n\r\nconst subscribeToDeviceManager = async (deviceManager: DeviceManager, dispatch: Dispatch, getState: () => State) => {\r\n  // listen for any new events\r\n  deviceManager.on('permissionStateChanged', async () => {\r\n    const cameraPermissionState: PermissionState = await deviceManager.getPermissionState('Camera');\r\n    dispatch(setCameraPermission(cameraPermissionState));\r\n\r\n    const microphonePermissionState: PermissionState = await deviceManager.getPermissionState('Microphone');\r\n    dispatch(setMicrophonePermission(microphonePermissionState));\r\n  });\r\n\r\n  deviceManager.on('videoDevicesUpdated', async () => {\r\n    updateVideoDevices(deviceManager, dispatch, getState);\r\n  });\r\n\r\n  deviceManager.on('audioDevicesUpdated', async () => {\r\n    updateAudioDevices(deviceManager, dispatch, getState);\r\n  });\r\n\r\n  deviceManager.askDevicePermission(true, true).then((e: DeviceAccess) => {\r\n    if (e.audio !== undefined) {\r\n      if (e.audio) {\r\n        dispatch(setMicrophonePermission('Granted'));\r\n\r\n        updateAudioDevices(deviceManager, dispatch, getState);\r\n      } else {\r\n        dispatch(setMicrophonePermission('Denied'));\r\n      }\r\n    }\r\n\r\n    if (e.video !== undefined) {\r\n      if (e.video) {\r\n        dispatch(setCameraPermission('Granted'));\r\n        updateVideoDevices(deviceManager, dispatch, getState);\r\n      } else {\r\n        dispatch(setCameraPermission('Denied'));\r\n      }\r\n    }\r\n  });\r\n};\r\n"]},"metadata":{},"sourceType":"module"}