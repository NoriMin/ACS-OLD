{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n// tslint:disable-next-line:no-null-keyword\nvar doc = document.implementation.createDocument(null, null, null);\nvar parser = new DOMParser();\nexport function parseXML(str, opts) {\n  try {\n    var dom = parser.parseFromString(str, \"application/xml\");\n    throwIfError(dom);\n    var obj = void 0;\n\n    if (opts && opts.includeRoot) {\n      obj = domToObject(dom);\n    } else {\n      obj = domToObject(dom.childNodes[0]);\n    }\n\n    return Promise.resolve(obj);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\nvar errorNS = \"\";\n\ntry {\n  errorNS = parser.parseFromString(\"INVALID\", \"text/xml\").getElementsByTagName(\"parsererror\")[0].namespaceURI;\n} catch (ignored) {// Most browsers will return a document containing <parsererror>, but IE will throw.\n}\n\nfunction throwIfError(dom) {\n  if (errorNS) {\n    var parserErrors = dom.getElementsByTagNameNS(errorNS, \"parsererror\");\n\n    if (parserErrors.length) {\n      throw new Error(parserErrors.item(0).innerHTML);\n    }\n  }\n}\n\nfunction isElement(node) {\n  return !!node.attributes;\n}\n/**\n * Get the Element-typed version of the provided Node if the provided node is an element with\n * attributes. If it isn't, then undefined is returned.\n */\n\n\nfunction asElementWithAttributes(node) {\n  return isElement(node) && node.hasAttributes() ? node : undefined;\n}\n\nfunction domToObject(node) {\n  var result = {};\n  var childNodeCount = node.childNodes.length;\n  var firstChildNode = node.childNodes[0];\n  var onlyChildTextValue = firstChildNode && childNodeCount === 1 && firstChildNode.nodeType === Node.TEXT_NODE && firstChildNode.nodeValue || undefined;\n  var elementWithAttributes = asElementWithAttributes(node);\n\n  if (elementWithAttributes) {\n    result[\"$\"] = {};\n\n    for (var i = 0; i < elementWithAttributes.attributes.length; i++) {\n      var attr = elementWithAttributes.attributes[i];\n      result[\"$\"][attr.nodeName] = attr.nodeValue;\n    }\n\n    if (onlyChildTextValue) {\n      result[\"_\"] = onlyChildTextValue;\n    }\n  } else if (childNodeCount === 0) {\n    result = \"\";\n  } else if (onlyChildTextValue) {\n    result = onlyChildTextValue;\n  }\n\n  if (!onlyChildTextValue) {\n    for (var i = 0; i < childNodeCount; i++) {\n      var child = node.childNodes[i]; // Ignore leading/trailing whitespace nodes\n\n      if (child.nodeType !== Node.TEXT_NODE) {\n        var childObject = domToObject(child);\n\n        if (!result[child.nodeName]) {\n          result[child.nodeName] = childObject;\n        } else if (Array.isArray(result[child.nodeName])) {\n          result[child.nodeName].push(childObject);\n        } else {\n          result[child.nodeName] = [result[child.nodeName], childObject];\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nvar serializer = new XMLSerializer();\nexport function stringifyXML(content, opts) {\n  var rootName = opts && opts.rootName || \"root\";\n  var dom = buildNode(content, rootName)[0];\n  return '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' + serializer.serializeToString(dom);\n}\n\nfunction buildAttributes(attrs) {\n  var result = [];\n\n  for (var _i = 0, _a = Object.keys(attrs); _i < _a.length; _i++) {\n    var key = _a[_i];\n    var attr = doc.createAttribute(key);\n    attr.value = attrs[key].toString();\n    result.push(attr);\n  }\n\n  return result;\n}\n\nfunction buildNode(obj, elementName) {\n  if (obj === undefined || obj === null || typeof obj === \"string\" || typeof obj === \"number\" || typeof obj === \"boolean\") {\n    var elem = doc.createElement(elementName);\n    elem.textContent = obj === undefined || obj === null ? \"\" : obj.toString();\n    return [elem];\n  } else if (Array.isArray(obj)) {\n    var result = [];\n\n    for (var _i = 0, obj_1 = obj; _i < obj_1.length; _i++) {\n      var arrayElem = obj_1[_i];\n\n      for (var _a = 0, _b = buildNode(arrayElem, elementName); _a < _b.length; _a++) {\n        var child = _b[_a];\n        result.push(child);\n      }\n    }\n\n    return result;\n  } else if (typeof obj === \"object\") {\n    var elem = doc.createElement(elementName);\n\n    for (var _c = 0, _d = Object.keys(obj); _c < _d.length; _c++) {\n      var key = _d[_c];\n\n      if (key === \"$\") {\n        for (var _e = 0, _f = buildAttributes(obj[key]); _e < _f.length; _e++) {\n          var attr = _f[_e];\n          elem.attributes.setNamedItem(attr);\n        }\n      } else if (key === \"_\") {\n        elem.textContent = obj[key].toString();\n      } else {\n        for (var _g = 0, _h = buildNode(obj[key], key); _g < _h.length; _g++) {\n          var child = _h[_g];\n          elem.appendChild(child);\n        }\n      }\n    }\n\n    return [elem];\n  } else {\n    throw new Error(\"Illegal value passed to buildObject: \" + obj);\n  }\n}","map":{"version":3,"sources":["../../../src/util/xml.browser.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n// tslint:disable-next-line:no-null-keyword\nconst doc = document.implementation.createDocument(null, null, null);\n\nconst parser = new DOMParser();\nexport function parseXML(str: string, opts?: { includeRoot?: boolean }): Promise<any> {\n  try {\n    const dom = parser.parseFromString(str, \"application/xml\");\n    throwIfError(dom);\n\n    let obj;\n    if (opts && opts.includeRoot) {\n      obj = domToObject(dom);\n    } else {\n      obj = domToObject(dom.childNodes[0]);\n    }\n\n    return Promise.resolve(obj);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\n\nlet errorNS = \"\";\ntry {\n  errorNS = parser.parseFromString(\"INVALID\", \"text/xml\").getElementsByTagName(\"parsererror\")[0]\n    .namespaceURI!;\n} catch (ignored) {\n  // Most browsers will return a document containing <parsererror>, but IE will throw.\n}\n\nfunction throwIfError(dom: Document): void {\n  if (errorNS) {\n    const parserErrors = dom.getElementsByTagNameNS(errorNS, \"parsererror\");\n    if (parserErrors.length) {\n      throw new Error(parserErrors.item(0)!.innerHTML);\n    }\n  }\n}\n\nfunction isElement(node: Node): node is Element {\n  return !!(node as Element).attributes;\n}\n\n/**\n * Get the Element-typed version of the provided Node if the provided node is an element with\n * attributes. If it isn't, then undefined is returned.\n */\nfunction asElementWithAttributes(node: Node): Element | undefined {\n  return isElement(node) && node.hasAttributes() ? node : undefined;\n}\n\nfunction domToObject(node: Node): any {\n  let result: any = {};\n\n  const childNodeCount: number = node.childNodes.length;\n\n  const firstChildNode: Node = node.childNodes[0];\n  const onlyChildTextValue: string | undefined =\n    (firstChildNode &&\n      childNodeCount === 1 &&\n      firstChildNode.nodeType === Node.TEXT_NODE &&\n      firstChildNode.nodeValue) ||\n    undefined;\n\n  const elementWithAttributes: Element | undefined = asElementWithAttributes(node);\n  if (elementWithAttributes) {\n    result[\"$\"] = {};\n\n    for (let i = 0; i < elementWithAttributes.attributes.length; i++) {\n      const attr = elementWithAttributes.attributes[i];\n      result[\"$\"][attr.nodeName] = attr.nodeValue;\n    }\n\n    if (onlyChildTextValue) {\n      result[\"_\"] = onlyChildTextValue;\n    }\n  } else if (childNodeCount === 0) {\n    result = \"\";\n  } else if (onlyChildTextValue) {\n    result = onlyChildTextValue;\n  }\n\n  if (!onlyChildTextValue) {\n    for (let i = 0; i < childNodeCount; i++) {\n      const child = node.childNodes[i];\n      // Ignore leading/trailing whitespace nodes\n      if (child.nodeType !== Node.TEXT_NODE) {\n        const childObject: any = domToObject(child);\n        if (!result[child.nodeName]) {\n          result[child.nodeName] = childObject;\n        } else if (Array.isArray(result[child.nodeName])) {\n          result[child.nodeName].push(childObject);\n        } else {\n          result[child.nodeName] = [result[child.nodeName], childObject];\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nconst serializer = new XMLSerializer();\n\nexport function stringifyXML(content: any, opts?: { rootName?: string }): string {\n  const rootName = (opts && opts.rootName) || \"root\";\n  const dom = buildNode(content, rootName)[0];\n  return (\n    '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' + serializer.serializeToString(dom)\n  );\n}\n\nfunction buildAttributes(attrs: { [key: string]: { toString(): string } }): Attr[] {\n  const result = [];\n  for (const key of Object.keys(attrs)) {\n    const attr = doc.createAttribute(key);\n    attr.value = attrs[key].toString();\n    result.push(attr);\n  }\n  return result;\n}\n\nfunction buildNode(obj: any, elementName: string): Node[] {\n  if (\n    obj === undefined ||\n    obj === null ||\n    typeof obj === \"string\" ||\n    typeof obj === \"number\" ||\n    typeof obj === \"boolean\"\n  ) {\n    const elem = doc.createElement(elementName);\n    elem.textContent = obj === undefined || obj === null ? \"\" : obj.toString();\n    return [elem];\n  } else if (Array.isArray(obj)) {\n    const result = [];\n    for (const arrayElem of obj) {\n      for (const child of buildNode(arrayElem, elementName)) {\n        result.push(child);\n      }\n    }\n    return result;\n  } else if (typeof obj === \"object\") {\n    const elem = doc.createElement(elementName);\n    for (const key of Object.keys(obj)) {\n      if (key === \"$\") {\n        for (const attr of buildAttributes(obj[key])) {\n          elem.attributes.setNamedItem(attr);\n        }\n      } else if (key === \"_\") {\n        elem.textContent = obj[key].toString();\n      } else {\n        for (const child of buildNode(obj[key], key)) {\n          elem.appendChild(child);\n        }\n      }\n    }\n    return [elem];\n  } else {\n    throw new Error(`Illegal value passed to buildObject: ${obj}`);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}