{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\t-tamina\\\\source\\\\repos\\\\Communication\\\\samples\\\\Group Calling Hero Sample\\\\Web\\\\Calling\\\\ClientApp\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __awaiter } from \"tslib\";\nimport { encodeUTF8, encodeBase64, encodeUTF8fromBase64 } from \"./encodeUtils.browser\";\nvar globalRef = globalThis;\n\nvar getCrypto = function getCrypto() {\n  if (!globalRef) {\n    throw new Error(\"Could not find global\");\n  }\n\n  if (!globalRef.crypto || !globalRef.crypto.subtle) {\n    throw new Error(\"Browser does not support cryptography functions\");\n  }\n\n  return globalRef.crypto.subtle;\n};\n\nexport var shaHash = function shaHash(content) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var data, hash;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            data = encodeUTF8(content);\n            _context.next = 3;\n            return getCrypto().digest(\"SHA-256\", data);\n\n          case 3:\n            hash = _context.sent;\n            return _context.abrupt(\"return\", encodeBase64(hash));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n};\nexport var shaHMAC = function shaHMAC(secret, content) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var importParams, encodedMessage, encodedKey, crypto, cryptoKey, signature;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            importParams = {\n              name: \"HMAC\",\n              hash: {\n                name: \"SHA-256\"\n              }\n            };\n            encodedMessage = encodeUTF8(content);\n            encodedKey = encodeUTF8fromBase64(secret);\n            crypto = getCrypto();\n            _context2.next = 6;\n            return crypto.importKey(\"raw\", encodedKey, importParams, false, [\"sign\"]);\n\n          case 6:\n            cryptoKey = _context2.sent;\n            _context2.next = 9;\n            return crypto.sign(importParams, cryptoKey, encodedMessage);\n\n          case 9:\n            signature = _context2.sent;\n            return _context2.abrupt(\"return\", encodeBase64(signature));\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n};","map":{"version":3,"sources":["../../../src/credential/cryptoUtils.browser.ts"],"names":[],"mappings":";AAAA;AACA;;AAEA,SAAS,UAAT,EAAqB,YAArB,EAAmC,oBAAnC,QAA+D,uBAA/D;AAEA,IAAM,SAAS,GAAQ,UAAvB;;AAEA,IAAM,SAAS,GAAG,SAAZ,SAAY,GAAmB;AACnC,MAAI,CAAC,SAAL,EAAgB;AACd,UAAM,IAAI,KAAJ,CAAU,uBAAV,CAAN;AACD;;AAED,MAAI,CAAC,SAAS,CAAC,MAAX,IAAqB,CAAC,SAAS,CAAC,MAAV,CAAiB,MAA3C,EAAmD;AACjD,UAAM,IAAI,KAAJ,CAAU,iDAAV,CAAN;AACD;;AAED,SAAO,SAAS,CAAC,MAAV,CAAiB,MAAxB;AACD,CAVD;;AAYA,OAAO,IAAM,OAAO,GAAG,SAAV,OAAU,CAAO,OAAP;AAAA,SAA2C,SAAA,CAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC1D,YAAA,IAD0D,GACnD,UAAU,CAAC,OAAD,CADyC;AAAA;AAEnD,mBAAM,SAAS,GAAG,MAAZ,CAAmB,SAAnB,EAA8B,IAA9B,CAAN;;AAFmD;AAE1D,YAAA,IAF0D;AAAA,6CAGzD,YAAY,CAAC,IAAD,CAH6C;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAA,EAA3C;AAAA,CAAhB;AAMP,OAAO,IAAM,OAAO,GAAG,SAAV,OAAU,CAAO,MAAP,EAAuB,OAAvB;AAAA,SAA2D,SAAA,CAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,wCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC1E,YAAA,YAD0E,GACzC;AAAE,cAAA,IAAI,EAAE,MAAR;AAAgB,cAAA,IAAI,EAAE;AAAE,gBAAA,IAAI,EAAE;AAAR;AAAtB,aADyC;AAE1E,YAAA,cAF0E,GAEzD,UAAU,CAAC,OAAD,CAF+C;AAG1E,YAAA,UAH0E,GAG7D,oBAAoB,CAAC,MAAD,CAHyC;AAI1E,YAAA,MAJ0E,GAIjE,SAAS,EAJwD;AAAA;AAK9D,mBAAM,MAAM,CAAC,SAAP,CAAiB,KAAjB,EAAwB,UAAxB,EAAoC,YAApC,EAAkD,KAAlD,EAAyD,CAAC,MAAD,CAAzD,CAAN;;AAL8D;AAK1E,YAAA,SAL0E;AAAA;AAM9D,mBAAM,MAAM,CAAC,IAAP,CAAY,YAAZ,EAA0B,SAA1B,EAAqC,cAArC,CAAN;;AAN8D;AAM1E,YAAA,SAN0E;AAAA,8CAOzE,YAAY,CAAC,SAAD,CAP6D;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAA,EAA3D;AAAA,CAAhB","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { encodeUTF8, encodeBase64, encodeUTF8fromBase64 } from \"./encodeUtils.browser\";\n\nconst globalRef: any = globalThis;\n\nconst getCrypto = (): SubtleCrypto => {\n  if (!globalRef) {\n    throw new Error(\"Could not find global\");\n  }\n\n  if (!globalRef.crypto || !globalRef.crypto.subtle) {\n    throw new Error(\"Browser does not support cryptography functions\");\n  }\n\n  return globalRef.crypto.subtle;\n};\n\nexport const shaHash = async (content: string): Promise<string> => {\n  const data = encodeUTF8(content);\n  const hash = await getCrypto().digest(\"SHA-256\", data);\n  return encodeBase64(hash);\n};\n\nexport const shaHMAC = async (secret: string, content: string): Promise<string> => {\n  const importParams: HmacImportParams = { name: \"HMAC\", hash: { name: \"SHA-256\" } };\n  const encodedMessage = encodeUTF8(content);\n  const encodedKey = encodeUTF8fromBase64(secret);\n  const crypto = getCrypto();\n  const cryptoKey = await crypto.importKey(\"raw\", encodedKey, importParams, false, [\"sign\"]);\n  const signature = await crypto.sign(importParams, cryptoKey, encodedMessage);\n  return encodeBase64(signature);\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}